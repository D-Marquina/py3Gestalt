

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>py3Gestalt.nodes &mdash; Gestalt Framework for Python 3 1 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../../genindex.html"/>
        <link rel="search" title="Search" href="../../search.html"/>
    <link rel="top" title="Gestalt Framework for Python 3 1 documentation" href="../../index.html"/>
        <link rel="up" title="Module code" href="../index.html"/> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> Gestalt Framework for Python 3
          

          
          </a>

          
            
            
              <div class="version">
                0.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">py3Gestalt Modules</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Gestalt Framework for Python 3</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>py3Gestalt.nodes</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for py3Gestalt.nodes</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Nodes module from Gestalt framework for Python 3.</span>

<span class="sd">Originally written by Ilan Moyer in 2013 and modified by Nadya Peek in 2015.</span>

<span class="sd">This module defines node classes and an node shell classes, which act</span>
<span class="sd">as an intermediary between the virtual nodes and the virtual machine.</span>

<span class="sd">TO-DO list:</span>
<span class="sd">- Complete load_from_module</span>
<span class="sd">- Decide load_from_file procedure</span>
<span class="sd">- Update is_vm_ill_defined based on is_vn_ill_defined</span>
<span class="sd">- Invetigate load_from_URL</span>

<span class="sd">Copyright (c) 2018 Daniel Marquina</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">importlib</span>  <span class="c1"># for importing files as modules</span>
<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">import</span> <span class="nn">shutil</span>
<span class="kn">import</span> <span class="nn">requests</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">threading</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">urllib</span>
<span class="kn">import</span> <span class="nn">pyclbr</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">from</span> <span class="nn">utilities</span> <span class="k">import</span> <span class="n">notice</span> <span class="k">as</span> <span class="n">notice</span>
<span class="kn">import</span> <span class="nn">interfaces</span>
<span class="c1"># from pygestalt import functions</span>
<span class="c1"># from pygestalt import packets</span>
<span class="c1"># from pygestalt import utilities</span>
<span class="c1"># from pygestalt import core</span>


<span class="c1"># ----NODE SHELLS------------</span>
<div class="viewcode-block" id="BaseNodeShell"><a class="viewcode-back" href="../../mod_nodes.html#py3Gestalt.nodes.BaseNodeShell">[docs]</a><span class="k">class</span> <span class="nc">BaseNodeShell</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The basic container for all nodes.</span>

<span class="sd">    Like a room in a hotel, that has different occupants and offers certain</span>
<span class="sd">    amenities to its guests. &#39;BaseNodeShell&#39; gets subclassed by more specific</span>
<span class="sd">    shells for one of the four types of gestalt nodes:</span>
<span class="sd">    -&gt;Solo/Independent: arbitrary interface/ arbitrary protocol</span>
<span class="sd">    -&gt;Solo/Gestalt: arbitrary interface/ gestalt protocol</span>
<span class="sd">    -&gt;Networked/Gestalt: networked gestalt interface/ gestalt protocol</span>
<span class="sd">    -&gt;Managed/Gestalt: hardware synchronized gestalt network/ gestalt protocol</span>

<span class="sd">    Args:</span>
<span class="sd">        owner (VirtualMachine or a child):</span>
<span class="sd">            Virtual machine that aims to own this node shell.</span>
<span class="sd">        name (str):</span>
<span class="sd">            Name of this node shell.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        owner (VirtualMachine or a child):</span>
<span class="sd">            Virtual machine that owns this node shell.</span>
<span class="sd">        name (str):</span>
<span class="sd">            Name of this node shell.</span>
<span class="sd">        use_debug_gui (boolean):</span>
<span class="sd">            Flag indicating use of a debugging GUI.</span>
<span class="sd">        debug_gui:</span>
<span class="sd">            GUI use for debugging purposes. For now it is a Py3GestaltGUI</span>
<span class="sd">            object.</span>
<span class="sd">        interface (InterfaceShell):</span>
<span class="sd">            Shell to contained owner&#39;s interface.</span>
<span class="sd">        vn_class (Class):</span>
<span class="sd">            Virtual node&#39;s class. The contained node will be an instance of</span>
<span class="sd">            this class.</span>
<span class="sd">        node (BaseVirtualNode or a child):</span>
<span class="sd">            Contained or linked node.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">owner</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">owner</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">owner</span><span class="o">.</span><span class="n">use_debug_gui</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">use_debug_gui</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">debug_gui</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">owner</span><span class="o">.</span><span class="n">debug_gui</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">use_debug_gui</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">debug_gui</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interface</span> <span class="o">=</span> <span class="n">interfaces</span><span class="o">.</span><span class="n">InterfaceShell</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vn_class</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="BaseNodeShell.__getattr__"><a class="viewcode-back" href="../../py3Gestalt.html#py3Gestalt.nodes.BaseNodeShell.__getattr__">[docs]</a>    <span class="k">def</span> <span class="nf">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attribute</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Forward any unsupported call to the shell onto the node.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># Shell contains a node.</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">,</span> <span class="n">attribute</span><span class="p">):</span>  <span class="c1"># node contains requested attribute</span>
                <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">,</span> <span class="n">attribute</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">notice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;Node does not have requested attribute.&quot;</span><span class="p">,</span>
                       <span class="bp">self</span><span class="o">.</span><span class="n">use_debug_gui</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="n">attribute</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">notice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;Node has not been initialized.&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_debug_gui</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="n">attribute</span><span class="p">)</span></div>

<div class="viewcode-block" id="BaseNodeShell.load_vn_from_file"><a class="viewcode-back" href="../../mod_nodes.html#py3Gestalt.nodes.BaseNodeShell.load_vn_from_file">[docs]</a>    <span class="k">def</span> <span class="nf">load_vn_from_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Load virtual node from a file.</span>

<span class="sd">        This functions gets the text from a file, imports it as a module and</span>
<span class="sd">        loads its defined virtual node&#39;.</span>

<span class="sd">        Note:</span>
<span class="sd">            If a file path is being passed, it is recommended to use</span>
<span class="sd">            &#39;os.path.join()&#39; as it creates a path according to the operating</span>
<span class="sd">            system.</span>

<span class="sd">        Args:</span>
<span class="sd">             filename (str): Name or path to file containing virtual node&#39;s</span>
<span class="sd">                definition.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">file_object</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>
        <span class="n">vn_imported_module</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">import_vn_module</span><span class="p">(</span><span class="n">file_object</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>
        <span class="n">file_object</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">load_vn_from_module</span><span class="p">(</span><span class="n">vn_imported_module</span><span class="p">,</span> <span class="n">checked</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="BaseNodeShell.load_vn_from_url"><a class="viewcode-back" href="../../mod_nodes.html#py3Gestalt.nodes.BaseNodeShell.load_vn_from_url">[docs]</a>    <span class="k">def</span> <span class="nf">load_vn_from_url</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">url</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Load virtual node from a url.</span>

<span class="sd">        This functions gets the text from a provided URL, imports it as a</span>
<span class="sd">        module and loads the defined virtual node.</span>

<span class="sd">        Args:</span>
<span class="sd">             url (str): URL directing to virtual node&#39;s definition.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">resp</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
        <span class="n">notice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">resp</span><span class="o">.</span><span class="n">text</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_debug_gui</span><span class="p">)</span>
        <span class="n">vn_imported_module</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">import_vn_module</span><span class="p">(</span><span class="n">resp</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">load_vn_from_module</span><span class="p">(</span><span class="n">vn_imported_module</span><span class="p">,</span> <span class="n">checked</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="BaseNodeShell.import_vn_module"><a class="viewcode-back" href="../../mod_nodes.html#py3Gestalt.nodes.BaseNodeShell.import_vn_module">[docs]</a>    <span class="k">def</span> <span class="nf">import_vn_module</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">module_content</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Import a user-defined virtual node module.</span>

<span class="sd">        Makes a temporal package (directory with an &#39;__init__.py&#39; file) called</span>
<span class="sd">        &#39;tmpVN&#39; with a temporal module (file) which contains a defined virtual</span>
<span class="sd">        node and imports it.</span>
<span class="sd">        They are assessed as &#39;temporal&#39; because they are deleted every time an</span>
<span class="sd">        import action is attempted.</span>

<span class="sd">        Note:</span>
<span class="sd">        The module&#39;s name is &#39;temp_virtual_node_X.py&#39;, where &#39;X&#39; is the number</span>
<span class="sd">        of import attempts. Such change of name is necessary in order to avoid</span>
<span class="sd">        problems next, when analyzing module&#39;s classes using &#39;pyclbr&#39;.</span>

<span class="sd">        Returns:</span>
<span class="sd">            vn_module: Imported virtual node.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">owner</span><span class="o">.</span><span class="n">node_file_counter</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">package</span> <span class="o">=</span> <span class="s1">&#39;tmpVN&#39;</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">package</span><span class="p">):</span>
            <span class="n">shutil</span><span class="o">.</span><span class="n">rmtree</span><span class="p">(</span><span class="n">package</span><span class="p">,</span> <span class="n">ignore_errors</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">package</span><span class="p">)</span>

        <span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">package</span><span class="p">,</span> <span class="s1">&#39;__init__.py&#39;</span><span class="p">),</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="n">module_name</span> <span class="o">=</span> <span class="s1">&#39;temp_virtual_node_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">owner</span><span class="o">.</span><span class="n">node_file_counter</span><span class="p">)</span>
        <span class="n">module_location</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">package</span><span class="p">,</span> <span class="n">module_name</span> <span class="o">+</span> <span class="s1">&#39;.py&#39;</span><span class="p">)</span>
        <span class="n">module_file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">module_location</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>
        <span class="n">module_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">module_content</span><span class="p">)</span>
        <span class="n">module_file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="n">module</span> <span class="o">=</span> <span class="n">package</span> <span class="o">+</span> <span class="s1">&#39;.&#39;</span> <span class="o">+</span> <span class="n">module_name</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_vn_ill_defined</span><span class="p">(</span><span class="n">module</span><span class="p">):</span>
            <span class="k">return</span>

        <span class="n">vn_module</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">import_module</span><span class="p">(</span><span class="n">module</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">package</span><span class="p">):</span>
            <span class="n">shutil</span><span class="o">.</span><span class="n">rmtree</span><span class="p">(</span><span class="n">package</span><span class="p">,</span> <span class="n">ignore_errors</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">vn_module</span></div>

<div class="viewcode-block" id="BaseNodeShell.load_vn_from_module"><a class="viewcode-back" href="../../mod_nodes.html#py3Gestalt.nodes.BaseNodeShell.load_vn_from_module">[docs]</a>    <span class="k">def</span> <span class="nf">load_vn_from_module</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">module</span><span class="p">,</span> <span class="n">checked</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Load virtual node from an imported module.</span>

<span class="sd">        Instantiates a virtual node from a class defined in provided module.</span>
<span class="sd">        Such module must have been already imported and should contain only one</span>
<span class="sd">        virtual node class that is a child of &#39;nodes.BaseVirtualNode&#39;. That</span>
<span class="sd">        last feature can be checked passing an argument &#39;checked&#39; as False.</span>

<span class="sd">        Args:</span>
<span class="sd">            module:</span>
<span class="sd">                Module containing virtual node&#39;s definition.</span>
<span class="sd">            checked (boolean):</span>
<span class="sd">                A flag indicating whether module&#39;s content (only one</span>
<span class="sd">                BaseVirtualNode&#39;s child class) has been checked or not.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">checked</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_vn_ill_defined</span><span class="p">(</span><span class="n">module</span><span class="o">.</span><span class="vm">__name__</span><span class="p">):</span>
                <span class="n">notice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;Provided module &#39;&quot;</span>
                       <span class="o">+</span> <span class="n">module</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span>
                       <span class="s2">&quot;.py&#39; was ill defined and could not be loaded.&quot;</span><span class="p">,</span>
                       <span class="bp">self</span><span class="o">.</span><span class="n">use_debug_gui</span><span class="p">)</span>
                <span class="k">return</span>

        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">(</span><span class="n">module</span><span class="p">):</span>
            <span class="bp">cls</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">inspect</span><span class="o">.</span><span class="n">isclass</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
                <span class="k">if</span> <span class="s2">&quot;BaseVirtualNode&quot;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__mro__</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">vn_class</span> <span class="o">=</span> <span class="bp">cls</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">notice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;Error - Virtual node class ill defined.&quot;</span><span class="p">,</span>
                           <span class="bp">self</span><span class="o">.</span><span class="n">use_debug_gui</span><span class="p">)</span>
                    <span class="k">return</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_node</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vn_class</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="BaseNodeShell.is_vn_ill_defined"><a class="viewcode-back" href="../../mod_nodes.html#py3Gestalt.nodes.BaseNodeShell.is_vn_ill_defined">[docs]</a>    <span class="k">def</span> <span class="nf">is_vn_ill_defined</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vn_module</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check whether a virtual node is ill defined or not.</span>

<span class="sd">        Makes sure that selected virtual node contains one and only one</span>
<span class="sd">        user-defined virtual machine class, child of &#39;nodes.BaseVirtualNode&#39;</span>
<span class="sd">        class.</span>

<span class="sd">        Args:</span>
<span class="sd">            vn_module: Virtual node module to be analyzed.</span>

<span class="sd">        Returns:</span>
<span class="sd">            True when selected module contains none or more than a unique</span>
<span class="sd">            virtual node. False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">num_of_vn_cls</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">class_data</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">pyclbr</span><span class="o">.</span><span class="n">readmodule</span><span class="p">(</span><span class="n">vn_module</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span>
                                       <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">lineno</span><span class="p">):</span>
            <span class="n">supers_list</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">class_data</span><span class="p">,</span> <span class="s1">&#39;super&#39;</span><span class="p">):</span>
                <span class="n">class_super</span> <span class="o">=</span> <span class="n">class_data</span><span class="o">.</span><span class="n">super</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">class_super</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">):</span>
                    <span class="k">while</span> <span class="n">class_super</span> <span class="o">!=</span> <span class="s1">&#39;object&#39;</span><span class="p">:</span>
                        <span class="n">supers_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">class_super</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                        <span class="n">class_super</span> <span class="o">=</span> <span class="n">class_super</span><span class="o">.</span><span class="n">super</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">supers_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;object&#39;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">supers_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">class_super</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="s1">&#39;BaseVirtualNode&#39;</span> <span class="ow">in</span> <span class="n">super_</span> <span class="k">for</span> <span class="n">super_</span> <span class="ow">in</span> <span class="n">supers_list</span><span class="p">):</span>
                <span class="n">num_of_vn_cls</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">num_of_vn_cls</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">notice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;Error: No virtual node defined.&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_debug_gui</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">num_of_vn_cls</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">notice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;Error: More than a unique virtual node defined in a &quot;</span>
                         <span class="s2">&quot;single file.&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_debug_gui</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="BaseNodeShell.set_node"><a class="viewcode-back" href="../../mod_nodes.html#py3Gestalt.nodes.BaseNodeShell.set_node">[docs]</a>    <span class="k">def</span> <span class="nf">set_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vn_class</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sets contained or linked node.</span>

<span class="sd">        Creates an instance of selected virtual node class and executes its</span>
<span class="sd">        &#39;init()&#39; method.</span>
<span class="sd">        Owner, name and interface from this shell are passed to contained node.</span>

<span class="sd">        Args:</span>
<span class="sd">            vn_class (Class):</span>
<span class="sd">                Virtual node class to be instantiated.</span>
<span class="sd">            kwargs:</span>
<span class="sd">                Arguments to be passed onto the virtual node&#39;s initialization.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node</span> <span class="o">=</span> <span class="n">vn_class</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">owner</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">notice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;Node assigned to &#39;&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;&#39; node shell.&quot;</span><span class="p">,</span>
               <span class="bp">self</span><span class="o">.</span><span class="n">use_debug_gui</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">shell</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">interface</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interface</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">init</span><span class="p">(</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">initKwargs</span><span class="p">)</span></div></div>

<span class="c1"># class soloIndependentNode(baseNodeShell):</span>
<span class="c1">#     &#39;&#39;&#39; A container shell for Solo/Independent nodes.</span>
<span class="c1">#</span>
<span class="c1">#         Solo/Independent nodes are non-networked and may use an arbitrary communications protocol.</span>
<span class="c1">#         For example, they could be a third-party device with a python plug-in, etc...</span>
<span class="c1">#     &#39;&#39;&#39;</span>
<span class="c1">#</span>
<span class="c1">#     def __init__(self, name=None, interface=None, filename=None, URL=None, module=None, **kwargs):</span>
<span class="c1">#         &#39;&#39;&#39;	Initialization procedure for Solo/Independent Node Shell.</span>
<span class="c1">#</span>
<span class="c1">#             name:		a unique name assigned by the user. This is used by the persistence algorithm to re-acquire the node.</span>
<span class="c1">#             interface: 	the object thru which the virtual node communicates with its physical counterpart.</span>
<span class="c1">#             **kwargs:	any additional arguments to be passed to the node during initialization</span>
<span class="c1">#</span>
<span class="c1">#             Methods of Loading Virtual Node:</span>
<span class="c1">#                 filename: an import-able module containing the virtual node.</span>
<span class="c1">#                 URL: a URL pointing to a module as a resource containing the virtual node.</span>
<span class="c1">#                 module: a python module name containing the virtual node.</span>
<span class="c1">#         &#39;&#39;&#39;</span>
<span class="c1">#</span>
<span class="c1">#         # call base class __init__ method</span>
<span class="c1">#         super(soloIndependentNode, self).__init__()</span>
<span class="c1">#</span>
<span class="c1">#         # assign parameters to variables</span>
<span class="c1">#         self.name = name</span>
<span class="c1">#         self.filename = filename</span>
<span class="c1">#         self.URL = URL</span>
<span class="c1">#         self.module = module</span>
<span class="c1">#         self.interface.set(interface, self)  # interface isn&#39;t shared with other nodes, so owner is self.</span>
<span class="c1">#</span>
<span class="c1">#         # acquire node. For an SI node, some method of acquisition MUST be provided, as it has no protocol for auto-loading.</span>
<span class="c1">#         # load via filename</span>
<span class="c1">#         if filename:</span>
<span class="c1">#             self.loadNodeFromFile(filename, **kwargs)</span>
<span class="c1">#         # load via URL</span>
<span class="c1">#         elif URL:</span>
<span class="c1">#             self.loadNodeFromURL(URL, **kwargs)</span>
<span class="c1">#         # load via module</span>
<span class="c1">#         elif module:</span>
<span class="c1">#             self.loadNodeFromModule(module, **kwargs)</span>
<span class="c1">#         else:</span>
<span class="c1">#             notice(self, &quot;no node source was provided.&quot;)</span>
<span class="c1">#             notice(self, &quot;please provide a filename, URL, or class&quot;)</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1"># class gestaltNodeShell(baseNodeShell):</span>
<span class="c1">#     &#39;&#39;&#39;Base class for all nodes which communicate using the gestalt protocol.&#39;&#39;&#39;</span>
<span class="c1">#</span>
<span class="c1">#     def __init__(self, name=None, interface=None, filename=None, URL=None, module=None, persistence=lambda: None,</span>
<span class="c1">#                  **kwargs):</span>
<span class="c1">#         &#39;&#39;&#39;	Initialization procedure for Gestalt Node Shell.</span>
<span class="c1">#</span>
<span class="c1">#             name:		a unique name assigned by the user. This is used by the persistence algorithm to re-acquire the node.</span>
<span class="c1">#             interface: 	the object thru which the virtual node communicates with its physical counterpart.</span>
<span class="c1">#             **kwargs:	any additional arguments to be passed to the node during initialization</span>
<span class="c1">#</span>
<span class="c1">#             Methods of Loading Virtual Node:</span>
<span class="c1">#                 filename: an import-able module containing the virtual node.</span>
<span class="c1">#                 URL: a URL pointing to a module as a resource containing the virtual node.</span>
<span class="c1">#                 module: a python module name containing the virtual node.</span>
<span class="c1">#</span>
<span class="c1">#             Networked/Gestalt virtual nodes initialize by associating with their counterparts over the network. A URL pointing to their driver is</span>
<span class="c1">#             returned upon association. This driver is then loaded into the shell as the virtual node.</span>
<span class="c1">#         &#39;&#39;&#39;</span>
<span class="c1">#</span>
<span class="c1">#         # call base class __init__ method</span>
<span class="c1">#         super(gestaltNodeShell, self).__init__()  # call init on baseNodeShell</span>
<span class="c1">#</span>
<span class="c1">#         # assign parameters to variables</span>
<span class="c1">#         self.name = name</span>
<span class="c1">#         self.filename = filename</span>
<span class="c1">#         self.URL = URL</span>
<span class="c1">#         self.module = module</span>
<span class="c1">#         self.persistence = persistence</span>
<span class="c1">#</span>
<span class="c1">#         # connect to interface</span>
<span class="c1">#         if interface:</span>
<span class="c1">#             # make sure that node has a gestalt interface</span>
<span class="c1">#             if type(interface) != interfaces.gestaltInterface:</span>
<span class="c1">#                 # wrap a gestalt interface around the provided interface</span>
<span class="c1">#                 self.interface.set(interfaces.gestaltInterface(interface=interface, owner=self), self)</span>
<span class="c1">#             else:</span>
<span class="c1">#                 self.interface.set(interface, self)  # interface isn&#39;t shared with other nodes, so owner is self.</span>
<span class="c1">#</span>
<span class="c1">#             # import base node</span>
<span class="c1">#             self.setNode(baseStandardGestaltNode())</span>
<span class="c1">#</span>
<span class="c1">#             if self.persistence():</span>
<span class="c1">#                 address = self.persistence.get(self.name)</span>
<span class="c1">#             else:</span>
<span class="c1">#                 address = None</span>
<span class="c1">#</span>
<span class="c1">#             if address:  # an IP address was found</span>
<span class="c1">#                 self.interface.assignNode(self.node, address)  # assign node to interface with IP address</span>
<span class="c1">#                 nodeURL = self.node.urlRequest()  # get node URL</span>
<span class="c1">#             else:  # acquire node</span>
<span class="c1">#                 # set node IP address	-- this will be changed later once persistence is added</span>
<span class="c1">#                 address = self.generateIPAddress()  # generate random IP address</span>
<span class="c1">#                 self.interface.assignNode(self.node, address)  # assign node to interface with IP address</span>
<span class="c1">#                 if type(self) == networkedGestaltNode: notice(self, &quot;please identify me on the network.&quot;)</span>
<span class="c1">#                 nodeURL = self.node.setIPRequest(address)  # set real node&#39;s IP address, and retrieve URL.</span>
<span class="c1">#                 if self.persistence(): self.persistence.store(self.name, address)</span>
<span class="c1">#</span>
<span class="c1">#             notice(self, nodeURL)</span>
<span class="c1">#</span>
<span class="c1">#             # try to start node in application mode</span>
<span class="c1">#             nodeStatus, appValid = self.statusRequest()</span>
<span class="c1">#             if nodeStatus == &#39;B&#39; and appValid:  # node is in bootloader mode and application is valid</span>
<span class="c1">#                 if self.runApplication():  # need to reinitialize</span>
<span class="c1">#                     nodeURL = self.urlRequest()</span>
<span class="c1">#                     notice(self, &quot; NOW RUNNING IN APPLICATION MODE&quot;)</span>
<span class="c1">#                     notice(self, nodeURL)  # remove</span>
<span class="c1">#                 else:</span>
<span class="c1">#                     notice(self, &quot;ERROR STARTING APPLICATION MODE&quot;)</span>
<span class="c1">#             elif nodeStatus == &#39;A&#39;:</span>
<span class="c1">#                 notice(self, &quot;RUNNING IN APPLICATION MODE&quot;)</span>
<span class="c1">#             else:</span>
<span class="c1">#                 notice(self, &quot; RUNNING IN BOOTLOADER MODE&quot;)</span>
<span class="c1">#</span>
<span class="c1">#         else:</span>
<span class="c1">#             # No interface, this can be intentional to allow debugging offline</span>
<span class="c1">#             notice(self, &#39;Error - please provide an interface.&#39;)</span>
<span class="c1">#</span>
<span class="c1">#         # acquire virtual node.</span>
<span class="c1">#         # if a virtual node source is provided, use that. Otherwise acquire from URL provided by node.</span>
<span class="c1">#         if filename:</span>
<span class="c1">#             if not self.loadNodeFromFile(filename, **kwargs): return</span>
<span class="c1">#         # load via URL</span>
<span class="c1">#         elif URL:</span>
<span class="c1">#             if not self.loadNodeFromURL(URL, **kwargs): return</span>
<span class="c1">#         # load via module</span>
<span class="c1">#         elif module:</span>
<span class="c1">#             if not self.loadNodeFromModule(module, **kwargs): return</span>
<span class="c1">#         # get URL from node</span>
<span class="c1">#         else:</span>
<span class="c1">#             if not self.loadNodeFromURL(nodeURL): return</span>
<span class="c1">#</span>
<span class="c1">#         if interface:</span>
<span class="c1">#             # assign new node with old IP address to interface. This replaces the default node with the imported node.</span>
<span class="c1">#             self.interface.assignNode(self.node, address)</span>
<span class="c1">#</span>
<span class="c1">#     def generateIPAddress(self):</span>
<span class="c1">#         &#39;&#39;&#39;Generates a random IP address.&#39;&#39;&#39;</span>
<span class="c1">#         while True:</span>
<span class="c1">#             IP = [random.randint(0, 255), random.randint(0, 255)]</span>
<span class="c1">#             if self.interface.validateIP(IP): break  # checks with interface to make sure IP address isn&#39;t taken.</span>
<span class="c1">#         return IP</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1"># class soloGestaltNode(gestaltNodeShell):</span>
<span class="c1">#     &#39;&#39;&#39;	A container shell for Solo/Gestalt nodes.</span>
<span class="c1">#</span>
<span class="c1">#         Solo/Gestalt nodes are non-networked and use the gestalt communications protocol.</span>
<span class="c1">#         For example they might make use of the gsArduino library.&#39;&#39;&#39;</span>
<span class="c1">#     pass</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1"># class networkedGestaltNode(gestaltNodeShell):</span>
<span class="c1">#     &#39;&#39;&#39;	A container shell for Networked/Gestalt nodes.</span>
<span class="c1">#</span>
<span class="c1">#         Networked/Gestalt nodes are networked and use the gestalt communications protocol.</span>
<span class="c1">#         Both the older Fabnet hardware as well as boards based on Units of Fab are supported.&#39;&#39;&#39;</span>
<span class="c1">#     pass</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1"># # ----VIRTUAL NODES------------</span>


<div class="viewcode-block" id="BaseVirtualNode"><a class="viewcode-back" href="../../mod_nodes.html#py3Gestalt.nodes.BaseVirtualNode">[docs]</a><span class="k">class</span> <span class="nc">BaseVirtualNode</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base class for virtual nodes.</span>

<span class="sd">    Initialization occurs in three steps:</span>
<span class="sd">            1) BaseVirtualNode gets initialized when instantiated.</span>
<span class="sd">            2) Node shell loads references into node through &#39;set_node()&#39; method.</span>
<span class="sd">            3) &#39;init()&#39; is called by &#39;set_node()&#39; method.</span>

<span class="sd">    The purpose of this routine is to initialize the nodes once they already</span>
<span class="sd">    have references to their shell.</span>

<span class="sd">    Args:</span>
<span class="sd">        owner (VirtualMachine or a child):</span>
<span class="sd">            Virtual machine that instantiates this node.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        owner (VirtualMachine or a child):</span>
<span class="sd">            Virtual machine that instantiates this node.</span>
<span class="sd">        shell (BaseNodeShell or a child):</span>
<span class="sd">            Node shell that contains this node.</span>
<span class="sd">        name (str):</span>
<span class="sd">            Name of this node shell.</span>
<span class="sd">        interface (InterfaceShell):</span>
<span class="sd">            Shell to contained owner&#39;s interface.</span>
<span class="sd">        use_debug_gui (boolean):</span>
<span class="sd">            Flag indicating use of a debugging GUI.</span>
<span class="sd">        debug_gui:</span>
<span class="sd">            GUI use for debugging purposes. For now it is a Py3GestaltGUI</span>
<span class="sd">            object.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">owner</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">owner</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shell</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interface</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initKwargs</span> <span class="o">=</span> <span class="n">kwargs</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">owner</span><span class="o">.</span><span class="n">use_debug_gui</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">use_debug_gui</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">debug_gui</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">owner</span><span class="o">.</span><span class="n">debug_gui</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">use_debug_gui</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">debug_gui</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_init</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Dummy initializer for child class.&quot;&quot;&quot;</span>
        <span class="k">pass</span>

<div class="viewcode-block" id="BaseVirtualNode.init"><a class="viewcode-back" href="../../mod_nodes.html#py3Gestalt.nodes.BaseVirtualNode.init">[docs]</a>    <span class="k">def</span> <span class="nf">init</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Dummy initializer for terminal child class.&quot;&quot;&quot;</span>
        <span class="k">pass</span></div></div>

<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1"># class baseSoloIndependentNode(baseVirtualNode):</span>
<span class="c1">#     &#39;&#39;&#39;base class for solo/independent virtual nodes&#39;&#39;&#39;</span>
<span class="c1">#     pass</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1"># class baseGestaltNode(baseVirtualNode):</span>
<span class="c1">#     &#39;&#39;&#39;base class for all gestalt nodes&#39;&#39;&#39;</span>
<span class="c1">#</span>
<span class="c1">#     def _init(self, **kwargs):</span>
<span class="c1">#         self.bindPort = self.bindPort(self)  # create binder function for node</span>
<span class="c1">#</span>
<span class="c1">#         self._initParameters()</span>
<span class="c1">#         self.initParameters()</span>
<span class="c1">#         self._initFunctions()</span>
<span class="c1">#         self.initFunctions()</span>
<span class="c1">#         self._initPackets()</span>
<span class="c1">#         self.initPackets()</span>
<span class="c1">#         self._initPorts()</span>
<span class="c1">#         self.initPorts()</span>
<span class="c1">#         # //FIX// need to make response flags specific to ports, otherwise packets can be recognized cross-port</span>
<span class="c1">#         self.responseFlag = threading.Event()  # this object is used for nodes to wait for a response</span>
<span class="c1">#</span>
<span class="c1">#     def _initParameters(self):</span>
<span class="c1">#         return</span>
<span class="c1">#</span>
<span class="c1">#     def initParameters(self):</span>
<span class="c1">#         return</span>
<span class="c1">#</span>
<span class="c1">#     def _initFunctions(self):</span>
<span class="c1">#         return</span>
<span class="c1">#</span>
<span class="c1">#     def initFunctions(self):</span>
<span class="c1">#         return</span>
<span class="c1">#</span>
<span class="c1">#     def _initPorts(self):</span>
<span class="c1">#         return</span>
<span class="c1">#</span>
<span class="c1">#     def initPorts(self):</span>
<span class="c1">#         return</span>
<span class="c1">#</span>
<span class="c1">#     def _initPackets(self):</span>
<span class="c1">#         return</span>
<span class="c1">#</span>
<span class="c1">#     def initPackets(self):</span>
<span class="c1">#         return</span>
<span class="c1">#</span>
<span class="c1">#     def _initLast(self):</span>
<span class="c1">#         return</span>
<span class="c1">#</span>
<span class="c1">#     def initLast(self):</span>
<span class="c1">#         return</span>
<span class="c1">#</span>
<span class="c1">#     def transmit(self, nodeSet, mode=&#39;unicast&#39;):</span>
<span class="c1">#         self.interface.transmit(nodeSet, mode)</span>
<span class="c1">#</span>
<span class="c1">#     def route(self, port, packet=None):</span>
<span class="c1">#         if packet == None: packet = []</span>
<span class="c1">#         if port in self.bindPort.inPorts:</span>
<span class="c1">#             destinationFunction = self.bindPort.inPorts[port]</span>
<span class="c1">#         else:</span>
<span class="c1">#             print</span>
<span class="c1">#             str(self) + &quot; RECEIVED A PACKET TO UNKOWN PORT &quot; + str(port)</span>
<span class="c1">#             return</span>
<span class="c1">#         destinationFunction.receiver(packet)</span>
<span class="c1">#         return</span>
<span class="c1">#</span>
<span class="c1">#     class bindPort():</span>
<span class="c1">#         def __init__(self, virtualNode):</span>
<span class="c1">#             self.virtualNode = virtualNode</span>
<span class="c1">#             self.outPorts = {}  # ports for outbound packets {function:port#}</span>
<span class="c1">#             self.inPorts = {}  # functions for inbound packets {port#:function}</span>
<span class="c1">#</span>
<span class="c1">#         def __call__(self, port, outboundFunction=None, outboundPacket=None, inboundFunction=None, inboundPacket=None):</span>
<span class="c1">#             newResponseFlag = threading.Event()</span>
<span class="c1">#             packetHolder = packets.packetHolder()</span>
<span class="c1">#</span>
<span class="c1">#             # ---CREATE FUNCTION INSTANCES AND UPDATE ROUTE DICTIONARIES---</span>
<span class="c1">#             if outboundFunction != None:</span>
<span class="c1">#                 if outboundPacket != None:</span>
<span class="c1">#                     packetSet = packets.packetSet(</span>
<span class="c1">#                         outboundPacket)  # gives the outbound function a packetSet initialized with the provided packet as a template</span>
<span class="c1">#                 else:</span>
<span class="c1">#                     packetSet = packets.packetSet(packets.packet(</span>
<span class="c1">#                         template=[]))  # gives the outbound function a packetSet initialized with a blank packet as a template</span>
<span class="c1">#                 if type(outboundFunction) == type: setattr(self.virtualNode, outboundFunction.__name__,</span>
<span class="c1">#                                                            outboundFunction(virtualNode=self.virtualNode,</span>
<span class="c1">#                                                                             # create function instance</span>
<span class="c1">#                                                                             packetSet=packetSet,  # define packet format</span>
<span class="c1">#                                                                             responseFlag=newResponseFlag,</span>
<span class="c1">#                                                                             # creates a common response flag for outbound and inbound functions</span>
<span class="c1">#                                                                             packetHolder=packetHolder))  # creates a common packet holder for outbound and inbound functions</span>
<span class="c1">#                 outboundFunction = getattr(self.virtualNode,</span>
<span class="c1">#                                            outboundFunction.__name__)  # update outboundFuncton pointer in event that new instance was created</span>
<span class="c1">#                 self.outPorts.update({outboundFunction: port})  # bind port to outbound instance</span>
<span class="c1">#</span>
<span class="c1">#             if inboundFunction != None:</span>
<span class="c1">#                 if inboundPacket != None:</span>
<span class="c1">#                     packetSet = packets.packetSet(</span>
<span class="c1">#                         inboundPacket)  # gives the inbound function a packetSet initialized with the provided packet as a template</span>
<span class="c1">#                 else:</span>
<span class="c1">#                     packetSet = packets.packetSet(packets.packet(</span>
<span class="c1">#                         template=[]))  # gives the inbound function a packetSet initialized with a blank packet as a template</span>
<span class="c1">#                 if type(inboundFunction) == type: setattr(self.virtualNode, inboundFunction.__name__,</span>
<span class="c1">#                                                           inboundFunction(virtualNode=self.virtualNode,</span>
<span class="c1">#                                                                           # create function instance</span>
<span class="c1">#                                                                           packetSet=packetSet,  # define packet format</span>
<span class="c1">#                                                                           responseFlag=newResponseFlag,</span>
<span class="c1">#                                                                           # creates a common response flag for outbound and inbound functions</span>
<span class="c1">#                                                                           packetHolder=packetHolder))  # creates a common packet holder for outbound and inbound functions</span>
<span class="c1">#                 inboundFunction = getattr(self.virtualNode, inboundFunction.__name__)</span>
<span class="c1">#                 self.inPorts.update({port: inboundFunction})  # bind port to inbound instance</span>
<span class="c1">#             else:  # create a default inbound function which will handle incoming packets.</span>
<span class="c1">#                 if inboundPacket != None:</span>
<span class="c1">#                     packetSet = packets.packetSet(inboundPacket)  # use provided inbound packet</span>
<span class="c1">#                 else:</span>
<span class="c1">#                     packetSet = packets.packetSet(packets.packet(template=[]))  # create default blank packet</span>
<span class="c1">#                 inboundFunction = functions.serviceRoutine(virtualNode=self.virtualNode, packetSet=packetSet,</span>
<span class="c1">#                                                            responseFlag=newResponseFlag, packetHolder=packetHolder)</span>
<span class="c1">#                 self.inPorts.update({port: inboundFunction})</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1"># class baseStandardGestaltNode(baseGestaltNode):</span>
<span class="c1">#</span>
<span class="c1">#     def _initParameters(self):</span>
<span class="c1">#         self.bootPageSize = 128</span>
<span class="c1">#</span>
<span class="c1">#     def _initPackets(self):</span>
<span class="c1">#         # status</span>
<span class="c1">#         self.statusResponsePacket = packets.packet(</span>
<span class="c1">#             template=[packets.pString(&#39;status&#39;, 1),  # status is encoded as &#39;b&#39; for bootloader, &#39;a&#39; for app.</span>
<span class="c1">#                       packets.pInteger(&#39;appValidity&#39;, 1)])  # app validity byte, gets set to 170 if app is valid</span>
<span class="c1">#</span>
<span class="c1">#         # bootloader command</span>
<span class="c1">#         self.bootCommandRequestPacket = packets.packet(template=[packets.pInteger(&#39;commandCode&#39;, 1)])</span>
<span class="c1">#         self.bootCommandResponsePacket = packets.packet(template=[packets.pInteger(&#39;responseCode&#39;, 1),</span>
<span class="c1">#                                                                   packets.pInteger(&#39;pageNumber&#39;, 2)])</span>
<span class="c1">#         # bootloader write</span>
<span class="c1">#         self.bootWriteRequestPacket = packets.packet(template=[packets.pInteger(&#39;commandCode&#39;, 1),</span>
<span class="c1">#                                                                packets.pInteger(&#39;pageNumber&#39;, 2),</span>
<span class="c1">#                                                                packets.pList(&#39;writeData&#39;, self.bootPageSize)])</span>
<span class="c1">#         self.bootWriteResponsePacket = packets.packet(self.bootCommandResponsePacket)</span>
<span class="c1">#</span>
<span class="c1">#         # bootloader read</span>
<span class="c1">#         self.bootReadRequestPacket = packets.packet(template=[packets.pInteger(&#39;pageNumber&#39;, 2)])</span>
<span class="c1">#         self.bootReadResponsePacket = packets.packet(template=[packets.pList(&#39;readData&#39;, self.bootPageSize)])</span>
<span class="c1">#</span>
<span class="c1">#         # request URL</span>
<span class="c1">#         self.urlResponsePacket = packets.packet(template=[packets.pString(&#39;URL&#39;)])</span>
<span class="c1">#</span>
<span class="c1">#         # set IP address</span>
<span class="c1">#         self.setIPRequestPacket = packets.packet(template=[packets.pList(&#39;setAddress&#39;, 2)])</span>
<span class="c1">#         self.setIPResponsePacket = packets.packet(self.urlResponsePacket)</span>
<span class="c1">#</span>
<span class="c1">#     # identify node</span>
<span class="c1">#     # no packet format</span>
<span class="c1">#</span>
<span class="c1">#     # reset node</span>
<span class="c1">#     # no packet format</span>
<span class="c1">#</span>
<span class="c1">#     def _initPorts(self):</span>
<span class="c1">#         # status</span>
<span class="c1">#         self.bindPort(port=1, outboundFunction=self.statusRequest, inboundPacket=self.statusResponsePacket)</span>
<span class="c1">#         # bootloader command</span>
<span class="c1">#         self.bindPort(port=2, outboundFunction=self.bootCommandRequest, outboundPacket=self.bootCommandRequestPacket,</span>
<span class="c1">#                       inboundPacket=self.bootCommandResponsePacket)</span>
<span class="c1">#         # bootloader write</span>
<span class="c1">#         self.bindPort(port=3, outboundFunction=self.bootWriteRequest, outboundPacket=self.bootWriteRequestPacket,</span>
<span class="c1">#                       inboundPacket=self.bootWriteResponsePacket)</span>
<span class="c1">#         # bootloader read</span>
<span class="c1">#         self.bindPort(port=4, outboundFunction=self.bootReadRequest, outboundPacket=self.bootReadRequestPacket,</span>
<span class="c1">#                       inboundPacket=self.bootReadResponsePacket)</span>
<span class="c1">#         # request url</span>
<span class="c1">#         self.bindPort(port=5, outboundFunction=self.urlRequest, inboundPacket=self.urlResponsePacket)</span>
<span class="c1">#         # set IP address</span>
<span class="c1">#         self.bindPort(port=6, outboundFunction=self.setIPRequest, outboundPacket=self.setIPRequestPacket,</span>
<span class="c1">#                       inboundPacket=self.setIPResponsePacket)</span>
<span class="c1">#         # identify node</span>
<span class="c1">#         self.bindPort(port=7, outboundFunction=self.identifyRequest)</span>
<span class="c1">#</span>
<span class="c1">#         # reset node</span>
<span class="c1">#         self.bindPort(port=255, outboundFunction=self.resetRequest)</span>
<span class="c1">#</span>
<span class="c1">#     def loadProgram(self, filename):</span>
<span class="c1">#         &#39;&#39;&#39;Loads a program into a Gestalt Node via the built-in Gestalt bootloader.&#39;&#39;&#39;</span>
<span class="c1">#         # initialize hex parser</span>
<span class="c1">#         parser = utilities.intelHexParser()  # Intel Hex Format Parser Object</span>
<span class="c1">#         parser.openHexFile(filename)</span>
<span class="c1">#         parser.loadHexFile()</span>
<span class="c1">#         pages = parser.returnPages(self.bootPageSize)</span>
<span class="c1">#         # reset node if necessary to switch to bootloader mode</span>
<span class="c1">#         nodeStatus, appValid = self.statusRequest()</span>
<span class="c1">#         if nodeStatus == &#39;A&#39;:  # currently in application, need to go to bootloader</span>
<span class="c1">#             self.resetRequest()  # attempt to reset node</span>
<span class="c1">#             nodeStatus, appValid = self.statusRequest()</span>
<span class="c1">#             if nodeStatus != &#39;B&#39;:</span>
<span class="c1">#                 notice(self, &quot;ERROR IN BOOTLOADER: CANNOT RESET NODE&quot;)</span>
<span class="c1">#                 return False</span>
<span class="c1">#         # initialize bootloader</span>
<span class="c1">#         if self.initBootload(): notice(self, &quot;BOOTLOADER INITIALIZED!&quot;)</span>
<span class="c1">#         # write hex file to node</span>
<span class="c1">#         for page in pages:</span>
<span class="c1">#             pageData = [addressBytePair[1] for addressBytePair in page]</span>
<span class="c1">#             pageNumber = self.bootWriteRequest(0, pageData)  # send page to bootloader</span>
<span class="c1">#             if pageNumber != page[0][0]:</span>
<span class="c1">#                 notice(self, &quot;Error in Bootloader: PAGE MISMATCH: SENT PAGE &quot; + str(</span>
<span class="c1">#                     page[0][0]) + &quot; AND NODE REPORTED PAGE &quot; + str(pageNumber))</span>
<span class="c1">#                 notice(self, &quot;ABORTING PROGRAM LOAD&quot;)</span>
<span class="c1">#                 return False</span>
<span class="c1">#             notice(self, &quot;WROTE PAGE &quot; + str(pageNumber))  # + &quot;: &quot; + str(pageData)</span>
<span class="c1">#         # verify hex file from node</span>
<span class="c1">#         for page in pages:</span>
<span class="c1">#             pageData = [addressBytePair[1] for addressBytePair in page]</span>
<span class="c1">#             currentPageNumber = page[0][0]</span>
<span class="c1">#             verifyData = self.bootReadRequest(currentPageNumber)</span>
<span class="c1">#             for index, item in enumerate(verifyData):</span>
<span class="c1">#                 if item != pageData[index]:</span>
<span class="c1">#                     notice(self, &quot;VERIFY ERROR IN PAGE: &quot; + str(currentPageNumber) + &quot; BYTE: &quot; + str(index))</span>
<span class="c1">#                     notice(self, &quot;VERIFY FAILED&quot;)</span>
<span class="c1">#                     return False</span>
<span class="c1">#             notice(self, &quot;PAGE &quot; + str(currentPageNumber) + &quot; VERIFIED!&quot;)</span>
<span class="c1">#         notice(self, &quot;VERIFY PASSED&quot;)</span>
<span class="c1">#         # start application</span>
<span class="c1">#         if not self.runApplication():</span>
<span class="c1">#             notice(self, &quot;COULD NOT START APPLICATION&quot;)</span>
<span class="c1">#             return FALSE</span>
<span class="c1">#         # register new node with gestalt interface</span>
<span class="c1">#         # self.target.nodeManager.assignNode(self)	#registers node with target</span>
<span class="c1">#         # need something here to import a new node into self.shell based on URL from node</span>
<span class="c1">#         return True</span>
<span class="c1">#</span>
<span class="c1">#     def initBootload(self):</span>
<span class="c1">#         return self.bootCommandRequest(&#39;startBootload&#39;)</span>
<span class="c1">#</span>
<span class="c1">#     def runApplication(self):</span>
<span class="c1">#         return self.bootCommandRequest(&#39;startApplication&#39;)</span>
<span class="c1">#</span>
<span class="c1">#     class statusRequest(functions.serviceRoutine):</span>
<span class="c1">#         class actionObject(core.actionObject):</span>
<span class="c1">#             def init(self):</span>
<span class="c1">#                 self.commitAndRelease()  # commit self immediately</span>
<span class="c1">#                 self.waitForChannelAccess()  # wait for channel access</span>
<span class="c1">#                 if self.transmitPersistent():</span>
<span class="c1">#                     return self.getPacket()[&#39;status&#39;], (</span>
<span class="c1">#                             self.getPacket()[&#39;appValidity&#39;] == 170)  # magic number for app validity</span>
<span class="c1">#</span>
<span class="c1">#     class bootCommandRequest(functions.serviceRoutine):</span>
<span class="c1">#         class actionObject(core.actionObject):</span>
<span class="c1">#             def init(self, command):</span>
<span class="c1">#                 commandSet = {&#39;startBootload&#39;: 0, &#39;startApplication&#39;: 1}</span>
<span class="c1">#                 responseSet = {&#39;bootloadStarted&#39;: 5,</span>
<span class="c1">#                                &#39;applicationStarted&#39;: 9}  # these numbers are arbitrary and defined in the firmware.</span>
<span class="c1">#                 if command in commandSet:</span>
<span class="c1">#                     self.setPacket({&#39;commandCode&#39;: commandSet[command]})</span>
<span class="c1">#                     self.commitAndRelease()  # commit self immediately</span>
<span class="c1">#                     self.waitForChannelAccess()</span>
<span class="c1">#                     if self.transmitPersistent():</span>
<span class="c1">#                         responseCode = self.getPacket()[&#39;responseCode&#39;]</span>
<span class="c1">#                         if command == &#39;startBootload&#39; and responseCode == responseSet[&#39;bootloadStarted&#39;]: return True</span>
<span class="c1">#                         if command == &#39;startAplication&#39; and responseCode == responseSet[</span>
<span class="c1">#                             &#39;applicationStarted&#39;]: return True</span>
<span class="c1">#                     else:</span>
<span class="c1">#                         print</span>
<span class="c1">#                         &quot;NO RESPONSE TO BOOTLOADER COMMAND &quot; + command</span>
<span class="c1">#                         return False</span>
<span class="c1">#                 else:</span>
<span class="c1">#                     print</span>
<span class="c1">#                     &quot;BOOTLOADER COMMAND &quot; + command + &quot; NOT RECOGNIZED.&quot;</span>
<span class="c1">#                     return False</span>
<span class="c1">#</span>
<span class="c1">#     class bootWriteRequest(functions.serviceRoutine):</span>
<span class="c1">#         class actionObject(core.actionObject):</span>
<span class="c1">#             def init(self, pageNumber, data):</span>
<span class="c1">#                 self.setPacket({&#39;commandCode&#39;: 2, &#39;pageNumber&#39;: pageNumber, &#39;writeData&#39;: data})</span>
<span class="c1">#                 self.commitAndRelease()  # commit self immediately</span>
<span class="c1">#                 self.waitForChannelAccess()</span>
<span class="c1">#                 if self.transmitPersistent():</span>
<span class="c1">#                     returnPacket = self.getPacket()</span>
<span class="c1">#                     if returnPacket[&#39;responseCode&#39;] == 1:  # page write OK</span>
<span class="c1">#                         return returnPacket[&#39;pageNumber&#39;]</span>
<span class="c1">#                     else:</span>
<span class="c1">#                         print</span>
<span class="c1">#                         &quot;PAGE WRITE NOT SUCCESSFUL ON NODE END&quot;</span>
<span class="c1">#                         return False</span>
<span class="c1">#                 else:</span>
<span class="c1">#                     print</span>
<span class="c1">#                     &quot;NO RESPONSE RECEIVED TO PAGE WRITE REQUEST&quot;</span>
<span class="c1">#                     return False</span>
<span class="c1">#</span>
<span class="c1">#     class bootReadRequest(functions.serviceRoutine):</span>
<span class="c1">#         class actionObject(core.actionObject):</span>
<span class="c1">#             def init(self, pageNumber):</span>
<span class="c1">#                 self.setPacket({&#39;pageNumber&#39;: pageNumber})</span>
<span class="c1">#                 self.commitAndRelease()  # commit self immediately</span>
<span class="c1">#                 self.waitForChannelAccess()</span>
<span class="c1">#                 if self.transmitPersistent():</span>
<span class="c1">#                     return self.getPacket()[&#39;readData&#39;]</span>
<span class="c1">#                 else:</span>
<span class="c1">#                     print</span>
<span class="c1">#                     &quot;NO RESPONSE RECEIVED TO PAGE WRITE REQUEST&quot;</span>
<span class="c1">#                     return False</span>
<span class="c1">#</span>
<span class="c1">#     class urlRequest(functions.serviceRoutine):</span>
<span class="c1">#         class actionObject(core.actionObject):</span>
<span class="c1">#             def init(self):</span>
<span class="c1">#                 self.commitAndRelease()  # commit self immediately</span>
<span class="c1">#                 self.waitForChannelAccess()</span>
<span class="c1">#                 if self.transmitPersistent():</span>
<span class="c1">#                     return self.getPacket()[&#39;URL&#39;]</span>
<span class="c1">#                 else:</span>
<span class="c1">#                     notice(self.virtualNode, &#39;NO URL RECEIVED&#39;)</span>
<span class="c1">#                     return False</span>
<span class="c1">#</span>
<span class="c1">#     class setIPRequest(functions.serviceRoutine):</span>
<span class="c1">#         class actionObject(core.actionObject):</span>
<span class="c1">#             def init(self, IP):</span>
<span class="c1">#                 self.setPacket({&#39;setAddress&#39;: IP}, mode=&#39;multicast&#39;)</span>
<span class="c1">#                 self.commitAndRelease()  # commit self immediately</span>
<span class="c1">#                 self.waitForChannelAccess(5)</span>
<span class="c1">#                 if self.transmitPersistent(timeout=15):</span>
<span class="c1">#                     time.sleep(1)  # debounce for button press</span>
<span class="c1">#                     return self.getPacket()[&#39;URL&#39;]</span>
<span class="c1">#                 else:</span>
<span class="c1">#                     notice(self.virtualNode, &#39;TIMEOUT WAITING FOR BUTTON PRESS&#39;)</span>
<span class="c1">#</span>
<span class="c1">#     class identifyRequest(functions.serviceRoutine):</span>
<span class="c1">#         class actionObject(core.actionObject):</span>
<span class="c1">#             def init(self):</span>
<span class="c1">#                 self.commitAndRelease()  # commit self immediately</span>
<span class="c1">#                 self.waitForChannelAccess()</span>
<span class="c1">#                 self.transmit()</span>
<span class="c1">#                 time.sleep(4)  # roughly the time that the LED is on.</span>
<span class="c1">#</span>
<span class="c1">#     class resetRequest(functions.serviceRoutine):</span>
<span class="c1">#         class actionObject(core.actionObject):</span>
<span class="c1">#             def init(self):</span>
<span class="c1">#                 self.commitAndRelease()  # commit self immediately</span>
<span class="c1">#                 self.waitForChannelAccess()</span>
<span class="c1">#                 self.transmit()</span>
<span class="c1">#                 time.sleep(0.1)  # give time for watchdog timer to reset</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1"># class compoundNode(object):</span>
<span class="c1">#     &#39;&#39;&#39;A compound node helps distribute and synchronize function calls across multiple nodes.&#39;&#39;&#39;</span>
<span class="c1">#</span>
<span class="c1">#     def __init__(self, *nodes):</span>
<span class="c1">#         self.nodes = nodes</span>
<span class="c1">#         self.nodeCount = len(self.nodes)</span>
<span class="c1">#         self.name = &quot;[&quot; + &#39;&#39;.join([str(node.name) + &quot;,&quot; for node in nodes])[:-1] + &quot;]&quot;</span>
<span class="c1">#         interfaces = [node.interface.Interface for node in nodes]  # nodes have an interface shell</span>
<span class="c1">#         if all(interface == interfaces[0] for interface in interfaces):</span>
<span class="c1">#             self.commonInterface = True</span>
<span class="c1">#         else:</span>
<span class="c1">#             self.commonInterface = False</span>
<span class="c1">#             notice(self, &quot;warning: not all members of compound node share a common interface!&quot;)</span>
<span class="c1">#</span>
<span class="c1">#     def __getattr__(self, attribute):</span>
<span class="c1">#         &#39;&#39;&#39;	Forwards all unsupported function calls to a distributor&#39;&#39;&#39;</span>
<span class="c1">#         return self.distributor(self, attribute)</span>
<span class="c1">#</span>
<span class="c1">#     class distributor(object):</span>
<span class="c1">#         &#39;&#39;&#39;The distributor is responsible for forwarding function calls made on the compound node to its constituents.</span>
<span class="c1">#</span>
<span class="c1">#         Arguments provided as tuples will be distributed individually. Non-tuple arguments will be duplicated to all</span>
<span class="c1">#         nodes.&#39;&#39;&#39;</span>
<span class="c1">#</span>
<span class="c1">#         def __init__(self, compoundNode, attribute):</span>
<span class="c1">#             self.attribute = attribute</span>
<span class="c1">#             self.compoundNode = compoundNode</span>
<span class="c1">#             self.sync = False  # indicates whether function call is synchronized. This gets set true if any arguments are tuples.</span>
<span class="c1">#</span>
<span class="c1">#         def __call__(self, *compoundArguments, **compoundKWarguments):</span>
<span class="c1">#             nodeArguments = [[] for i in range(self.compoundNode.nodeCount)]  # a list of arguments for each node</span>
<span class="c1">#             nodeKWarguments = [{} for i in range(self.compoundNode.nodeCount)]  # a list of kwarguments for each node</span>
<span class="c1">#</span>
<span class="c1">#             # If a tuple is provided, the items are distributed to respective arguments out lists. Otherwise, the item is copied to all lists.</span>
<span class="c1">#</span>
<span class="c1">#             # compile arguments</span>
<span class="c1">#             for argument in compoundArguments:</span>
<span class="c1">#                 if type(argument) == tuple:  # tuple provided, should distribute</span>
<span class="c1">#                     if len(</span>
<span class="c1">#                             argument) != self.compoundNode.nodeCount:  # check to make sure that tuple length matches the number of nodes.</span>
<span class="c1">#                         alert(self.compoundNode, self.attribute + &quot;: not enough arguments provided in tuple.&quot;)</span>
<span class="c1">#                         return False</span>
<span class="c1">#                     else:</span>
<span class="c1">#                         self.sync = True  # tuple provided, this will be a synchronized call.</span>
<span class="c1">#                         for nodeArgPair in zip(nodeArguments,</span>
<span class="c1">#                                                list(argument)):  # iterate thru (targetArgumentList, argument)</span>
<span class="c1">#                             currentNodeArguments = nodeArgPair[0]</span>
<span class="c1">#                             currentNodeArguments += [nodeArgPair[1]]</span>
<span class="c1">#                 else:</span>
<span class="c1">#                     for node in nodeArguments:</span>
<span class="c1">#                         node += [argument]</span>
<span class="c1">#</span>
<span class="c1">#             # compile keyword arguments</span>
<span class="c1">#             for key, value in compoundKWarguments.iteritems():</span>
<span class="c1">#                 if type(value) == tuple:  # tuple provided, should distribute</span>
<span class="c1">#                     if len(value) != self.compoundNode.nodeCount:</span>
<span class="c1">#                         alert(self.compoundNode, self.attribute + &quot;: not enough arguments provided in tuple.&quot;)</span>
<span class="c1">#                         return False</span>
<span class="c1">#                     else:</span>
<span class="c1">#                         self.sync = True</span>
<span class="c1">#                         for nodeArgPair in zip(nodeKWarguments, list(value)):</span>
<span class="c1">#                             currentNodeArguments = nodeArgPair[0]</span>
<span class="c1">#                             currentNodeArguments.update({key: nodeArgPair[1]})</span>
<span class="c1">#                 else:</span>
<span class="c1">#                     for node in nodeKWarguments:</span>
<span class="c1">#                         node.update({key: value})</span>
<span class="c1">#</span>
<span class="c1">#             #			if sync, provide a sync token</span>
<span class="c1">#             if self.sync:</span>
<span class="c1">#                 syncToken = core.syncToken()  # pull a new sync token</span>
<span class="c1">#                 for node in nodeKWarguments:</span>
<span class="c1">#                     node.update({&#39;sync&#39;: syncToken})</span>
<span class="c1">#</span>
<span class="c1">#             #			make function calls</span>
<span class="c1">#             returnValues = [self.nodeFunctionCall(node, self.attribute, args, kwargs) for node, args, kwargs in</span>
<span class="c1">#                             zip(self.compoundNode.nodes, nodeArguments, nodeKWarguments)]</span>
<span class="c1">#</span>
<span class="c1">#             if self.sync:</span>
<span class="c1">#                 return core.actionSet(returnValues)</span>
<span class="c1">#             else:</span>
<span class="c1">#                 return returnValues</span>
<span class="c1">#</span>
<span class="c1">#         def nodeFunctionCall(self, node, attribute, args, kwargs):</span>
<span class="c1">#             if hasattr(node, attribute):</span>
<span class="c1">#                 return getattr(node, attribute)(*list(args), **kwargs)</span>
<span class="c1">#             else:</span>
<span class="c1">#                 notice(self.compoundNode, &quot;NODE DOESN&#39;T HAVE REQUESTED ATTRIBUTE&quot;)</span>
<span class="c1">#                 raise AttributeError(attribute)</span>
</pre></div>

           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, Daniel Marquina.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'1',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>