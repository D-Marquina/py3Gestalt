

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>py3gestalt.interfaces &mdash; Gestalt Framework for Python 3 1 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../../genindex.html"/>
        <link rel="search" title="Search" href="../../search.html"/>
    <link rel="top" title="Gestalt Framework for Python 3 1 documentation" href="../../index.html"/>
        <link rel="up" title="Module code" href="../index.html"/> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> Gestalt Framework for Python 3
          

          
          </a>

          
            
            
              <div class="version">
                0.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">py3Gestalt Modules</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Gestalt Framework for Python 3</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>py3gestalt.interfaces</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for py3gestalt.interfaces</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Interfaces module from Gestalt framework for Python 3.</span>

<span class="sd">Originally written by Ilan Moyer in 2013 and modified by Nadya Peek in 2015.</span>

<span class="sd">This module defines interface classes and an interface shell class, which acts</span>
<span class="sd">as an intermediary between the interface and nodes.</span>

<span class="sd">- &#39;InterfaceShell&#39; class:</span>
<span class="sd">    A wrapper that links the real interface object to classes and methods that</span>
<span class="sd">    try to access it.</span>
<span class="sd">- &#39;BaseInterface&#39; class:</span>
<span class="sd">    A basic example of an interface object. Every interface should be based on it.</span>
<span class="sd">- &#39;SerialInterface&#39; class:</span>
<span class="sd">    Defines an interface that uses a serial port.</span>

<span class="sd">Copyright (c) 2018 Daniel Marquina</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">py3gestalt</span> <span class="k">import</span> <span class="n">core</span>
<span class="kn">from</span> <span class="nn">py3gestalt</span> <span class="k">import</span> <span class="n">packets</span>
<span class="kn">from</span> <span class="nn">py3gestalt</span> <span class="k">import</span> <span class="n">functions</span>
<span class="kn">from</span> <span class="nn">py3gestalt.utilities</span> <span class="k">import</span> <span class="n">notice</span><span class="p">,</span> <span class="n">get_available_serial_ports</span><span class="p">,</span> \
    <span class="n">scan_serial_ports</span>
<span class="kn">import</span> <span class="nn">threading</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">platform</span>
<span class="kn">import</span> <span class="nn">serial</span>
<span class="kn">import</span> <span class="nn">socket</span>
<span class="kn">import</span> <span class="nn">queue</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">os</span>


<div class="viewcode-block" id="InterfaceShell"><a class="viewcode-back" href="../../mod_interfaces.html#py3gestalt.interfaces.InterfaceShell">[docs]</a><span class="k">class</span> <span class="nc">InterfaceShell</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Intermediary between nodes, node shells and interfaces.</span>

<span class="sd">    Args:</span>
<span class="sd">        owner: Object that initializes this interface shell. It could be a</span>
<span class="sd">            virtual machine, a virtual node, etc.</span>
<span class="sd">        interface (BaseInterface):</span>
<span class="sd">            Interface to be contained by this shell.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        owner: Object that owns this shell. Used in the port acquisition process.</span>
<span class="sd">        contained_interface (BaseInterface or a child): Interface contained by</span>
<span class="sd">            this shell.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">owner</span><span class="p">,</span> <span class="n">interface</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">owner</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">contained_interface</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">interface</span><span class="p">,</span> <span class="n">owner</span><span class="p">)</span>

<div class="viewcode-block" id="InterfaceShell.set"><a class="viewcode-back" href="../../mod_interfaces.html#py3gestalt.interfaces.InterfaceShell.set">[docs]</a>    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interface</span><span class="p">,</span> <span class="n">owner</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Update the interface contained by the shell.</span>

<span class="sd">        Also initializes contained (or linked) shell. Owner can be None. This</span>
<span class="sd">        method is called when a node is initialized.</span>

<span class="sd">        Args:</span>
<span class="sd">            interface (BaseInterface): Interface to be contained by this shell.</span>
<span class="sd">            owner: Object that will own this interface shell.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">owner</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">owner</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">contained_interface</span> <span class="o">=</span> <span class="n">interface</span>
        <span class="k">if</span> <span class="n">interface</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">owner</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">contained_interface</span><span class="o">.</span><span class="n">owner</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">owner</span>
        <span class="k">if</span> <span class="n">interface</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">contained_interface</span><span class="o">.</span><span class="n">init_after_set</span><span class="p">()</span></div>

<div class="viewcode-block" id="InterfaceShell.set_owner"><a class="viewcode-back" href="../../mod_interfaces.html#py3gestalt.interfaces.InterfaceShell.set_owner">[docs]</a>    <span class="k">def</span> <span class="nf">set_owner</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">owner</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set owner.</span>

<span class="sd">         Updates owner of this shell and its contained interface.</span>
<span class="sd">         Useful when no owner was specified when instantiating.</span>

<span class="sd">         Args:</span>
<span class="sd">             owner: New owner of this interface shell.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">owner</span>  <span class="c1"># used in the port acquisition process</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">contained_interface</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">contained_interface</span><span class="o">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">owner</span></div>

    <span class="k">def</span> <span class="nf">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attribute</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Forward attribute calls to the contained interface.</span>

<span class="sd">        Args:</span>
<span class="sd">            attribute: Contained interface&#39;s attribute to be called.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Contained interfaces&#39;s attribute.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">contained_interface</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">contained_interface</span><span class="p">,</span> <span class="n">attribute</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">contained_interface</span><span class="p">,</span> <span class="n">attribute</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">notice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;Interface does not have requested attribute.&quot;</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="n">attribute</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">notice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;Interface shell is empty.&quot;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="n">attribute</span><span class="p">)</span></div>


<div class="viewcode-block" id="BaseInterface"><a class="viewcode-back" href="../../mod_interfaces.html#py3gestalt.interfaces.BaseInterface">[docs]</a><span class="k">class</span> <span class="nc">BaseInterface</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base class of all interfaces.</span>

<span class="sd">    Args:</span>
<span class="sd">        owner: Object that initializes this interface.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        owner: Object that owns this interface.</span>

<span class="sd">    This class presents a basic structure of all interfaces. Currently, it only</span>
<span class="sd">    has an empty method which will be overridden by a child class defined</span>
<span class="sd">    later.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">owner</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">owner</span>

<div class="viewcode-block" id="BaseInterface.init_after_set"><a class="viewcode-back" href="../../mod_interfaces.html#py3gestalt.interfaces.BaseInterface.init_after_set">[docs]</a>    <span class="k">def</span> <span class="nf">init_after_set</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Connect to interface after it was assigned to an interface shell.&quot;&quot;&quot;</span>
        <span class="k">pass</span></div></div>


<div class="viewcode-block" id="SerialInterface"><a class="viewcode-back" href="../../mod_interfaces.html#py3gestalt.interfaces.SerialInterface">[docs]</a><span class="k">class</span> <span class="nc">SerialInterface</span><span class="p">(</span><span class="n">BaseInterface</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Serial communication interface.</span>

<span class="sd">    The core of this class is a serial object. For data transmission, a queue</span>
<span class="sd">    stores all data to be sent whereas a thread handles transmission of every</span>
<span class="sd">    element in that queue.</span>
<span class="sd">    As data reception using a thread requires a defined</span>
<span class="sd">    protocol, a simple method reads a number of bytes from the input buffer.</span>

<span class="sd">    Args:</span>
<span class="sd">        owner: Object that instantiates this interface.</span>
<span class="sd">        baud_rate (int): Speed in baud.</span>
<span class="sd">        port_name (str): Name of port to connect.</span>
<span class="sd">        interface_type (str): Type of interface, &#39;ftdi&#39; or &#39;arduino&#39; for now.</span>
<span class="sd">        time_out (float): Time to wait for a new device to be connected, in</span>
<span class="sd">            seconds.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        owner (VirtualMachine): Object that owns this interface.</span>
<span class="sd">        baudRate (int): Speed in baud.</span>
<span class="sd">        portName (str): Name of connected port.</span>
<span class="sd">        interfaceType (str): Type of interface, &#39;ftdi&#39; or &#39;lufa&#39; for now.</span>
<span class="sd">        timeOut (float): Time to wait for a new device to be connected.</span>
<span class="sd">        isConnected (boolean): State of connection.</span>
<span class="sd">        port (serial): Serial object to use.</span>
<span class="sd">        transmitQueue (Queue): A queue to store to-be-transmitted packets from</span>
<span class="sd">            different sources.</span>
<span class="sd">        transmitter (TransmitThread): A thread to handle data transmission.</span>

<span class="sd">    Note:</span>
<span class="sd">        Regarding the attribute &#39;interfaceType&#39;, a third value may be used,</span>
<span class="sd">        &#39;genericSerial&#39;, but its use could potentially cause problems because of</span>
<span class="sd">        its generic implementation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">owner</span><span class="p">,</span> <span class="n">baud_rate</span><span class="p">,</span> <span class="n">port_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">interface_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">time_out</span><span class="o">=</span><span class="mf">0.2</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SerialInterface</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">owner</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">baudRate</span> <span class="o">=</span> <span class="n">baud_rate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">portName</span> <span class="o">=</span> <span class="n">port_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interfaceType</span> <span class="o">=</span> <span class="n">interface_type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timeOut</span> <span class="o">=</span> <span class="n">time_out</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">isConnected</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">port</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># a queue is used to allow multiple threads to call transmit simultaneously.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transmitQueue</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">Queue</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transmitter</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="SerialInterface.init_after_set"><a class="viewcode-back" href="../../mod_interfaces.html#py3gestalt.interfaces.SerialInterface.init_after_set">[docs]</a>    <span class="k">def</span> <span class="nf">init_after_set</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize after setting.</span>

<span class="sd">        Begins connection procedure. First, it tries to connect to provided</span>
<span class="sd">        port name; if there is no port name, it waits for a new port to be</span>
<span class="sd">        created based on a provided interface type.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">portName</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">portName</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">interfaceType</span><span class="p">:</span>
            <span class="c1"># if an interface type is provided, auto-acquire</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">acquire_port_and_connect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">interfaceType</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">notice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;Serial interface could not be initialized. A port name or an &quot;</span>
                         <span class="s2">&quot;interface type are required.&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="SerialInterface.connect"><a class="viewcode-back" href="../../mod_interfaces.html#py3gestalt.interfaces.SerialInterface.connect">[docs]</a>    <span class="k">def</span> <span class="nf">connect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">port_name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Connect to serial port.</span>

<span class="sd">        Connects to specified port name. Tries to connect to port assigned on</span>
<span class="sd">        instantiation if no port is specified as argument.</span>

<span class="sd">        Args:</span>
<span class="sd">            port_name (str): Name of serial port.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">port_name</span><span class="p">:</span>
            <span class="n">port</span> <span class="o">=</span> <span class="n">port_name</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">portName</span><span class="p">:</span>
            <span class="n">port</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">portName</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">notice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;No port name provided.&#39;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">port</span> <span class="o">=</span> <span class="n">serial</span><span class="o">.</span><span class="n">Serial</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">baudRate</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">timeOut</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">serial</span><span class="o">.</span><span class="n">SerialException</span><span class="p">:</span>
            <span class="n">notice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;Error when opening serial port &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">port</span><span class="p">))</span>
            <span class="k">return</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">port</span><span class="o">.</span><span class="n">flushInput</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">port</span><span class="o">.</span><span class="n">flushOutput</span><span class="p">()</span>
        <span class="n">notice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;Port &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">port</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; connected successfully.&quot;</span><span class="p">)</span>
        <span class="c1"># Some serial ports need some time between opening and transmission</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">isConnected</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start_transmitter</span><span class="p">()</span></div>

<div class="viewcode-block" id="SerialInterface.acquire_port_and_connect"><a class="viewcode-back" href="../../mod_interfaces.html#py3gestalt.interfaces.SerialInterface.acquire_port_and_connect">[docs]</a>    <span class="k">def</span> <span class="nf">acquire_port_and_connect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interface_type</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Acquire a serial port and connect to it.</span>

<span class="sd">        Tries to detect a serial port based on the provided interface type.</span>
<span class="sd">        If no serial port is detected, it waits some seconds (10 by default)</span>
<span class="sd">        for a new one to be created.</span>

<span class="sd">        Args:</span>
<span class="sd">             interface_type (str): Type of interface.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Call to connect function if a port was detected. Exits, otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">serial_filter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_serial_filter_terms</span><span class="p">(</span><span class="n">interface_type</span><span class="p">)</span>
        <span class="n">available_ports</span> <span class="o">=</span> <span class="n">get_available_serial_ports</span><span class="p">(</span><span class="n">serial_filter</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">available_ports</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Connects to the only available port that matches the filter.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">portName</span> <span class="o">=</span> <span class="n">available_ports</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">notice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;Trying to acquire serial port. You have 10 seconds to &quot;</span>
                         <span class="s2">&quot;plug an interface in.&quot;</span><span class="p">)</span>
            <span class="n">new_ports</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wait_for_new_port</span><span class="p">(</span><span class="n">serial_filter</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">new_ports</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_ports</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">notice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">owner</span><span class="p">,</span>
                           <span class="s2">&quot;Could not acquire. Multiple ports plugged in &quot;</span>
                           <span class="s2">&quot;simultaneously.&quot;</span><span class="p">)</span>
                    <span class="k">return</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">portName</span> <span class="o">=</span> <span class="n">new_ports</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span></div>

<div class="viewcode-block" id="SerialInterface.get_serial_filter_terms"><a class="viewcode-back" href="../../mod_interfaces.html#py3gestalt.interfaces.SerialInterface.get_serial_filter_terms">[docs]</a>    <span class="k">def</span> <span class="nf">get_serial_filter_terms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interface_type</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get filter terms for serial ports.</span>

<span class="sd">        According to the operating system, selects a type of filter and the</span>
<span class="sd">        filter term.</span>
<span class="sd">        For example, in the case of Arduino, the type is &#39;manufacturer&#39; and the</span>
<span class="sd">        filter term is &#39;Arduino&#39;. This implementation allows the inclusion of</span>
<span class="sd">        new interfaces.</span>

<span class="sd">        Note:</span>
<span class="sd">            Currently, the type of filter should be one attribute of</span>
<span class="sd">            serial.tools.list_ports.ListPortInfo class, supported by your operating</span>
<span class="sd">            system (Windows, Linux os MacOS).</span>

<span class="sd">        Note:</span>
<span class="sd">            The use of interface type &#39;genericSerial&#39; should be avoided</span>
<span class="sd">            because many devices could share the provided filter term.</span>

<span class="sd">        Args:</span>
<span class="sd">            interface_type (str): Type of interface, &#39;ftdi&#39; for FTDI devices,</span>
<span class="sd">                &#39;Arduino&#39; for Arduino and &#39;generic serial&#39; for others.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A list of filter type and filter term respectively, if found on</span>
<span class="sd">            the dictionary. False, otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ftdi_terms</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Windows&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;manufacturer&#39;</span><span class="p">,</span> <span class="s1">&#39;FTDI&#39;</span><span class="p">],</span>
                      <span class="s1">&#39;Linux&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;manufacturer&#39;</span><span class="p">,</span> <span class="s1">&#39;FTDI&#39;</span><span class="p">],</span>
                      <span class="s1">&#39;Darwin&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;manufacturer&#39;</span><span class="p">,</span> <span class="s1">&#39;FTDI&#39;</span><span class="p">]}</span>
        <span class="n">arduino_terms</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Windows&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;manufacturer&#39;</span><span class="p">,</span> <span class="s1">&#39;Arduino&#39;</span><span class="p">],</span>
                         <span class="s1">&#39;Linux&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;manufacturer&#39;</span><span class="p">,</span> <span class="s1">&#39;Arduino&#39;</span><span class="p">],</span>
                         <span class="s1">&#39;Darwin&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;manufacturer&#39;</span><span class="p">,</span> <span class="s1">&#39;Arduino&#39;</span><span class="p">]}</span>
        <span class="n">generic_serial_terms</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Windows&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;device&#39;</span><span class="p">,</span> <span class="s1">&#39;COM&#39;</span><span class="p">],</span>
                                <span class="s1">&#39;Linux&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;device&#39;</span><span class="p">,</span> <span class="s1">&#39;tty&#39;</span><span class="p">],</span>
                                <span class="s1">&#39;Darwin&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;device&#39;</span><span class="p">,</span> <span class="s1">&#39;tty.&#39;</span><span class="p">]}</span>
        <span class="n">terms_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;ftdi&#39;</span><span class="p">:</span> <span class="n">ftdi_terms</span><span class="p">,</span> <span class="s1">&#39;arduino&#39;</span><span class="p">:</span> <span class="n">arduino_terms</span><span class="p">,</span>
                      <span class="s1">&#39;genericSerial&#39;</span><span class="p">:</span> <span class="n">generic_serial_terms</span><span class="p">}</span>
        <span class="n">op_sys</span> <span class="o">=</span> <span class="n">platform</span><span class="o">.</span><span class="n">system</span><span class="p">()</span>  <span class="c1"># nominally detects the system</span>
        <span class="k">if</span> <span class="n">interface_type</span> <span class="ow">in</span> <span class="n">terms_dict</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">op_sys</span> <span class="ow">in</span> <span class="n">terms_dict</span><span class="p">[</span><span class="n">interface_type</span><span class="p">]:</span>
                <span class="k">return</span> <span class="n">terms_dict</span><span class="p">[</span><span class="n">interface_type</span><span class="p">][</span><span class="n">op_sys</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">notice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                       <span class="s2">&quot;Operating system support not found for interface type &#39;&quot;</span> <span class="o">+</span>
                       <span class="n">interface_type</span> <span class="o">+</span> <span class="s2">&quot;&#39;&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">notice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                   <span class="s2">&quot;Interface support not found for interface type &#39;&quot;</span> <span class="o">+</span>
                   <span class="n">interface_type</span> <span class="o">+</span> <span class="s2">&quot;&#39;&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="SerialInterface.wait_for_new_port"><a class="viewcode-back" href="../../mod_interfaces.html#py3gestalt.interfaces.SerialInterface.wait_for_new_port">[docs]</a>    <span class="k">def</span> <span class="nf">wait_for_new_port</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filter_term</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">time_limit</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Wait for a new port to be created.</span>

<span class="sd">        This function waits for the user to connect an interface device and</span>
<span class="sd">        returns its new serial port.</span>

<span class="sd">        Args:</span>
<span class="sd">            filter_term (str): Optional serial port filter, depends on</span>
<span class="sd">                interface type and operating system.</span>
<span class="sd">            time_limit (float): Maximum number of seconds to wait for a new</span>
<span class="sd">                port to be created.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A list of new serial ports. False, otherwise.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">timer_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">old_ports</span> <span class="o">=</span> <span class="n">scan_serial_ports</span><span class="p">(</span><span class="n">filter_term</span><span class="p">)</span>
        <span class="n">num_old_ports</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">old_ports</span><span class="p">)</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.25</span><span class="p">)</span>
            <span class="n">timer_count</span> <span class="o">+=</span> <span class="mf">0.25</span>
            <span class="k">if</span> <span class="n">timer_count</span> <span class="o">&gt;</span> <span class="n">time_limit</span><span class="p">:</span>
                <span class="n">notice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">owner</span><span class="p">,</span> <span class="s1">&#39;TIMEOUT while trying to acquire a new port.&#39;</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="n">new_ports</span> <span class="o">=</span> <span class="n">scan_serial_ports</span><span class="p">(</span><span class="n">filter_term</span><span class="p">)</span>
            <span class="n">num_new_ports</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_ports</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">num_new_ports</span> <span class="o">&lt;</span> <span class="n">num_old_ports</span><span class="p">:</span>
                <span class="c1"># A device has been unplugged, update info</span>
                <span class="n">old_ports</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">new_ports</span><span class="p">)</span>
                <span class="n">num_old_ports</span> <span class="o">=</span> <span class="n">num_new_ports</span>
            <span class="k">elif</span> <span class="n">num_new_ports</span> <span class="o">&gt;</span> <span class="n">num_old_ports</span><span class="p">:</span>
                <span class="c1"># Returns all ports that just appeared</span>
                <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">new_ports</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">old_ports</span><span class="p">))</span></div>

<div class="viewcode-block" id="SerialInterface.start_transmitter"><a class="viewcode-back" href="../../mod_interfaces.html#py3gestalt.interfaces.SerialInterface.start_transmitter">[docs]</a>    <span class="k">def</span> <span class="nf">start_transmitter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Start the transmit thread.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transmitter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">TransmitThread</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">transmitQueue</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">port</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transmitter</span><span class="o">.</span><span class="n">daemon</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transmitter</span><span class="o">.</span><span class="n">start</span><span class="p">()</span></div>

<div class="viewcode-block" id="SerialInterface.transmit"><a class="viewcode-back" href="../../mod_interfaces.html#py3gestalt.interfaces.SerialInterface.transmit">[docs]</a>    <span class="k">def</span> <span class="nf">transmit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add data to transmit queue.</span>

<span class="sd">        As a thread handles data transmission, it continuously checks the</span>
<span class="sd">        transmit queue and sends data when added by this function.</span>
<span class="sd">        String data is converted to a list by default.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isConnected</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">transmitQueue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">notice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;Serial interface is not connected.&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="SerialInterface.read_bytes"><a class="viewcode-back" href="../../mod_interfaces.html#py3gestalt.interfaces.SerialInterface.read_bytes">[docs]</a>    <span class="k">def</span> <span class="nf">read_bytes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bytes_to_read</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Read a number of bytes from the serial port&#39;s input buffer.</span>

<span class="sd">        If there are less bytes available, read only the available ones.</span>

<span class="sd">        Args:</span>
<span class="sd">            bytes_to_read (int): Number of bytes to grab.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Read bytes, if received. None, otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">port</span><span class="p">:</span>
            <span class="n">available_bytes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">port</span><span class="o">.</span><span class="n">in_waiting</span>
            <span class="k">if</span> <span class="n">bytes_to_read</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">port</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">bytes_to_read</span><span class="p">,</span> <span class="n">available_bytes</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">port</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">available_bytes</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="SerialInterface.TransmitThread"><a class="viewcode-back" href="../../mod_interfaces.html#py3gestalt.interfaces.SerialInterface.TransmitThread">[docs]</a>    <span class="k">class</span> <span class="nc">TransmitThread</span><span class="p">(</span><span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A thread to handle data transmission data over a serial port.</span>

<span class="sd">        Args:</span>
<span class="sd">            owner (SerialInterface): Interface that instantiates this thread.</span>
<span class="sd">            transmit_queue (Queue): Queue that stores to-be-transmitted packets.</span>
<span class="sd">            port (Serial): Serial port to be used.</span>

<span class="sd">        Attributes:</span>
<span class="sd">            owner (SerialInterface): Interface that owns this thread.</span>
<span class="sd">            transmitQueue (Queue): Queue that stores to-be-transmitted packets.</span>
<span class="sd">            port (Serial): Serial port to be used.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">owner</span><span class="p">,</span> <span class="n">transmit_queue</span><span class="p">,</span> <span class="n">port</span><span class="p">):</span>
            <span class="nb">super</span><span class="p">(</span><span class="n">SerialInterface</span><span class="o">.</span><span class="n">TransmitThread</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">owner</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">transmitQueue</span> <span class="o">=</span> <span class="n">transmit_queue</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">port</span> <span class="o">=</span> <span class="n">port</span>

<div class="viewcode-block" id="SerialInterface.TransmitThread.run"><a class="viewcode-back" href="../../mod_interfaces.html#py3gestalt.interfaces.SerialInterface.TransmitThread.run">[docs]</a>        <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Define code to be ran by the transmit thread.</span>

<span class="sd">            Gets a packet from transmit queue, converts it into a string and</span>
<span class="sd">            transmits it.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">transmit_state</span><span class="p">,</span> <span class="n">transmit_packet</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_transmit_packet</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">transmit_state</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">port</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">port</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">serialize</span><span class="p">(</span><span class="n">transmit_packet</span><span class="p">)</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">notice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;Cannot transmit. No serial port &quot;</span>
                                     <span class="s2">&quot;initialized.&quot;</span><span class="p">)</span>
                <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.0005</span><span class="p">)</span>
            <span class="k">pass</span></div>

<div class="viewcode-block" id="SerialInterface.TransmitThread.get_transmit_packet"><a class="viewcode-back" href="../../mod_interfaces.html#py3gestalt.interfaces.SerialInterface.TransmitThread.get_transmit_packet">[docs]</a>        <span class="k">def</span> <span class="nf">get_transmit_packet</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Get a to-be-transmitted packet from the transmit queue.</span>

<span class="sd">            Returns:</span>
<span class="sd">                True and first packet from transmit queue, if it was not empty.</span>
<span class="sd">                False and None, otherwise.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">transmitQueue</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
            <span class="k">except</span> <span class="n">queue</span><span class="o">.</span><span class="n">Empty</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">None</span>
            <span class="k">pass</span></div>

<div class="viewcode-block" id="SerialInterface.TransmitThread.serialize"><a class="viewcode-back" href="../../mod_interfaces.html#py3gestalt.interfaces.SerialInterface.TransmitThread.serialize">[docs]</a>        <span class="k">def</span> <span class="nf">serialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">packet</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Convert packet into a string for transmission over a serial port.</span>

<span class="sd">            Uses ASCII characters.</span>

<span class="sd">            Returns:</span>
<span class="sd">                Packet as string if it was a list or a string. False, otherwise.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">packet</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">:</span>
                <span class="k">return</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">chr</span><span class="p">(</span><span class="n">byte</span><span class="p">)</span> <span class="k">for</span> <span class="n">byte</span> <span class="ow">in</span> <span class="n">packet</span><span class="p">])</span>
            <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">packet</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">packet</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">notice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                       <span class="s2">&quot;Error: Packet must be either a list or a string.&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">False</span></div></div></div>

<span class="c1"># class gestaltInterface(baseInterface):</span>
<span class="c1">#     &#39;&#39;&#39;Interface to Gestalt nodes based on the Gestalt protocol.&#39;&#39;&#39;</span>
<span class="c1">#</span>
<span class="c1">#     def __init__(self, name=None, interface=None, owner=None):</span>
<span class="c1">#         self.name = name  # name becomes important for networked gestalt</span>
<span class="c1">#         self.owner = owner</span>
<span class="c1">#         self.interface = interfaceShell(interface,</span>
<span class="c1">#                                         self)  # uses the interfaceShell object for connecting to sub-interface</span>
<span class="c1">#</span>
<span class="c1">#         self.receiveQueue = Queue.Queue()</span>
<span class="c1">#         self.CRC = CRC()</span>
<span class="c1">#         self.nodeManager = self.nodeManager()  # used to map network addresses (physical devices) to nodes</span>
<span class="c1">#</span>
<span class="c1">#         self.startInterfaceThreads()  # this will start the receiver, packetRouter, channelPriority, and channelAccess threads.</span>
<span class="c1">#</span>
<span class="c1">#         # define standard gestalt packet</span>
<span class="c1">#         self.gestaltPacket = packets.packet(template=[packets.pInteger(&#39;startByte&#39;, 1),</span>
<span class="c1">#                                                       packets.pList(&#39;address&#39;, 2),</span>
<span class="c1">#                                                       packets.pInteger(&#39;port&#39;, 1),</span>
<span class="c1">#                                                       packets.pLength(),</span>
<span class="c1">#                                                       packets.pList(&#39;payload&#39;)])</span>
<span class="c1">#</span>
<span class="c1">#     def validateIP(self, IP):</span>
<span class="c1">#         &#39;&#39;&#39;Makes sure that an IP address isn&#39;t already in use on the interface.&#39;&#39;&#39;</span>
<span class="c1">#         if str(IP) in self.nodeManager.address_node:</span>
<span class="c1">#             return False</span>
<span class="c1">#         else:</span>
<span class="c1">#             return True</span>
<span class="c1">#</span>
<span class="c1">#     class nodeManager(object):</span>
<span class="c1">#         &#39;&#39;&#39;Manages all nodes under the control of this interface.&#39;&#39;&#39;</span>
<span class="c1">#</span>
<span class="c1">#         def __init__(self):</span>
<span class="c1">#             self.node_address = {}  # node : address</span>
<span class="c1">#             self.address_node = {}  # address: node</span>
<span class="c1">#</span>
<span class="c1">#         def updateNodesAddresses(self, node, address):</span>
<span class="c1">#             oldNode = None</span>
<span class="c1">#             oldAddress = None</span>
<span class="c1">#</span>
<span class="c1">#             if str(address) in self.address_node: oldNode = self.address_node[str(address)]</span>
<span class="c1">#             if node in self.node_address: oldAddress = self.node_address[node]</span>
<span class="c1">#</span>
<span class="c1">#             if str(oldAddress) in self.address_node: self.address_node.pop(str(oldAddress))</span>
<span class="c1">#             if oldNode in self.node_address: self.node_address.pop(oldNode)</span>
<span class="c1">#</span>
<span class="c1">#             self.address_node.update({str(address): node})</span>
<span class="c1">#             self.node_address.update({node: address})</span>
<span class="c1">#</span>
<span class="c1">#         def getIP(self, node):</span>
<span class="c1">#             &#39;&#39;&#39;Returns IP address for a given node.&#39;&#39;&#39;</span>
<span class="c1">#             if node in self.node_address:</span>
<span class="c1">#                 return self.node_address[node]</span>
<span class="c1">#             else:</span>
<span class="c1">#                 return False</span>
<span class="c1">#</span>
<span class="c1">#         def getNode(self, IP):</span>
<span class="c1">#             IP = str(IP)</span>
<span class="c1">#             if IP in self.address_node:</span>
<span class="c1">#                 return self.address_node[IP]</span>
<span class="c1">#             else:</span>
<span class="c1">#                 return False</span>
<span class="c1">#</span>
<span class="c1">#     def assignNode(self, node, address):</span>
<span class="c1">#         &#39;&#39;&#39;Assigns a given node to the interface on a particular address.&#39;&#39;&#39;</span>
<span class="c1">#         self.nodeManager.updateNodesAddresses(node, address)</span>
<span class="c1">#</span>
<span class="c1">#     def transmit(self, virtualNode, port, packetSet, mode):</span>
<span class="c1">#         &#39;&#39;&#39;Transmits a packet set over the interface immediately.&#39;&#39;&#39;</span>
<span class="c1">#         # --BUILD START BYTE TABLE--</span>
<span class="c1">#         startByteTable = {&#39;unicast&#39;: 72,</span>
<span class="c1">#                           &#39;multicast&#39;: 138}  # unicast transmits to addressed node, multicast to all nodes on network</span>
<span class="c1">#         if mode in startByteTable:</span>
<span class="c1">#             startByte = startByteTable[mode]</span>
<span class="c1">#         else:</span>
<span class="c1">#             startByte = startByteTable[&#39;unicast&#39;]</span>
<span class="c1">#</span>
<span class="c1">#         # --TRANSMIT PACKETS--</span>
<span class="c1">#         address = self.nodeManager.getIP(virtualNode)</span>
<span class="c1">#         for packet in packetSet:</span>
<span class="c1">#             packetRoutable = self.gestaltPacket(</span>
<span class="c1">#                 {&#39;startByte&#39;: startByte, &#39;address&#39;: address, &#39;port&#39;: port, &#39;payload&#39;: packet})  # build packet</span>
<span class="c1">#             packetWChecksum = self.CRC(packetRoutable)  # generate CRC</span>
<span class="c1">#             self.interface.transmit(packetWChecksum)  # transmit packet thru interface</span>
<span class="c1">#</span>
<span class="c1">#     def commit(self, actionObject):</span>
<span class="c1">#         &#39;&#39;&#39;Puts actionObjects or actionSets into the channelPriority queue.&#39;&#39;&#39;</span>
<span class="c1">#         self.channelPriority.putActionObject(actionObject)</span>
<span class="c1">#</span>
<span class="c1">#     def startInterfaceThreads(self):</span>
<span class="c1">#         &#39;&#39;&#39;Initiates the receiver thread.&#39;&#39;&#39;</span>
<span class="c1">#         # START RECEIVE THREAD</span>
<span class="c1">#         self.receiver = self.receiveThread(self)</span>
<span class="c1">#         self.receiver.daemon = True</span>
<span class="c1">#         self.receiver.start()</span>
<span class="c1">#         # START ROUTER THREAD</span>
<span class="c1">#         self.packetRouter = self.packetRouterThread(self)</span>
<span class="c1">#         self.packetRouter.daemon = True</span>
<span class="c1">#         self.packetRouter.start()</span>
<span class="c1">#         # START CHANNEL PRIORITY THREAD</span>
<span class="c1">#         self.channelPriority = self.channelPriorityThread(self)</span>
<span class="c1">#         self.channelPriority.daemon = True</span>
<span class="c1">#         self.channelPriority.start()</span>
<span class="c1">#         # START CHANNEL ACCESS THREAD</span>
<span class="c1">#         self.channelAccess = self.channelAccessThread(self)</span>
<span class="c1">#         self.channelAccess.daemon = True</span>
<span class="c1">#         self.channelAccess.start()</span>
<span class="c1">#</span>
<span class="c1">#     class receiveThread(threading.Thread):</span>
<span class="c1">#         &#39;&#39;&#39;Gets packets from the network interface, interpreting them, and pushing them to the router queue.&#39;&#39;&#39;</span>
<span class="c1">#</span>
<span class="c1">#         def __init__(self, interface):</span>
<span class="c1">#             threading.Thread.__init__(self)</span>
<span class="c1">#             self.interface = interface</span>
<span class="c1">#</span>
<span class="c1">#         #			print &quot;GESTALT INTERFACE RECEIVE THREAD INITIALIZED&quot;</span>
<span class="c1">#</span>
<span class="c1">#         def run(self):</span>
<span class="c1">#             packet = []</span>
<span class="c1">#             inPacket = False</span>
<span class="c1">#             packetPosition = 0</span>
<span class="c1">#             packetLength = 5</span>
<span class="c1">#</span>
<span class="c1">#             while True:</span>
<span class="c1">#                 byte = self.interface.interface.receive()  # get byte</span>
<span class="c1">#                 if byte:</span>
<span class="c1">#                     byte = ord(byte)  # converts char to byte</span>
<span class="c1">#                     if not inPacket:</span>
<span class="c1">#                         if byte == 72 or byte == 138:  # waits for start byte</span>
<span class="c1">#                             inPacket = True</span>
<span class="c1">#                             packet += [byte]  # adds start byte to packet</span>
<span class="c1">#                             packetPosition += 1  # increment packet position</span>
<span class="c1">#                             continue  # otherwise rejects packet</span>
<span class="c1">#                     else:  # in a packet</span>
<span class="c1">#                         packet += [byte]  # append byte to packet</span>
<span class="c1">#</span>
<span class="c1">#                         if packetPosition == 4:  # byte 2 contains the packet position</span>
<span class="c1">#                             packetLength = byte</span>
<span class="c1">#                             packetPosition += 1  # increment packet position</span>
<span class="c1">#                             continue</span>
<span class="c1">#</span>
<span class="c1">#                         if packetPosition &lt; packetLength:</span>
<span class="c1">#                             packetPosition += 1  # increment packet position</span>
<span class="c1">#                             continue</span>
<span class="c1">#</span>
<span class="c1">#                         if packetPosition == packetLength:</span>
<span class="c1">#                             if self.interface.CRC.validate(packet): self.interface.packetRouter.routerQueue.put(</span>
<span class="c1">#                                 packet[:len(packet) - 1])  # check CRC, then send to router (minus CRC)</span>
<span class="c1">#</span>
<span class="c1">#                 # initialize packet</span>
<span class="c1">#                 packet = []</span>
<span class="c1">#                 inPacket = False</span>
<span class="c1">#                 packetPosition = 0</span>
<span class="c1">#                 packetLength = 5</span>
<span class="c1">#</span>
<span class="c1">#                 time.sleep(0.0005)</span>
<span class="c1">#</span>
<span class="c1">#     class packetRouterThread(threading.Thread):</span>
<span class="c1">#         &#39;&#39;&#39;Routes packets to their matching service routines, and executes the service routine within this thread.&#39;&#39;&#39;</span>
<span class="c1">#</span>
<span class="c1">#         def __init__(self, interface):</span>
<span class="c1">#             threading.Thread.__init__(self)</span>
<span class="c1">#             self.interface = interface</span>
<span class="c1">#             self.routerQueue = Queue.Queue()</span>
<span class="c1">#</span>
<span class="c1">#         def run(self):</span>
<span class="c1">#             while True:</span>
<span class="c1">#                 routerState, routerPacket = self.getRouterPacket()</span>
<span class="c1">#                 if routerState:</span>
<span class="c1">#                     parsedPacket = self.interface.gestaltPacket.decode(routerPacket)</span>
<span class="c1">#                     address = parsedPacket[&#39;address&#39;]</span>
<span class="c1">#                     port = parsedPacket[&#39;port&#39;]</span>
<span class="c1">#                     data = parsedPacket[&#39;payload&#39;]</span>
<span class="c1">#                     destinationNode = self.interface.nodeManager.getNode(address)</span>
<span class="c1">#                     if not destinationNode:</span>
<span class="c1">#                         print</span>
<span class="c1">#                         &quot;PACEKT RECEIVED FOR UNKNOWN ADDRESS &quot; + str(address)</span>
<span class="c1">#                         continue</span>
<span class="c1">#                     destinationNode.route(port, data)</span>
<span class="c1">#</span>
<span class="c1">#                 time.sleep(0.0005)</span>
<span class="c1">#</span>
<span class="c1">#         def getRouterPacket(self):</span>
<span class="c1">#             try:</span>
<span class="c1">#                 return True, self.routerQueue.get()</span>
<span class="c1">#             except:</span>
<span class="c1">#                 return False, None</span>
<span class="c1">#</span>
<span class="c1">#     class channelAccessThread(threading.Thread):</span>
<span class="c1">#         &#39;&#39;&#39;Controls when action objects have access to the interface.</span>
<span class="c1">#</span>
<span class="c1">#             channelAccessQueue contains a serialized list of actionObjects which have been cleared for transmission and</span>
<span class="c1">#             are waiting for access to the channel.&#39;&#39;&#39;</span>
<span class="c1">#</span>
<span class="c1">#         def __init__(self, interface):</span>
<span class="c1">#             threading.Thread.__init__(self)</span>
<span class="c1">#             self.interface = interface</span>
<span class="c1">#             self.channelAccessQueue = Queue.Queue()</span>
<span class="c1">#</span>
<span class="c1">#         # might add another queue here for when actionObjects need to be transmitted immediately.</span>
<span class="c1">#</span>
<span class="c1">#         def run(self):</span>
<span class="c1">#             while True:</span>
<span class="c1">#                 accessQueueState, actionObject = self.getActionObject()  # get the next action object from the queue.</span>
<span class="c1">#                 if accessQueueState:</span>
<span class="c1">#                     actionObject.grantAccess()  # actionObject now has control of the channel.</span>
<span class="c1">#                 time.sleep(0.0005)</span>
<span class="c1">#</span>
<span class="c1">#         def getActionObject(self):</span>
<span class="c1">#             try:</span>
<span class="c1">#                 return True, self.channelAccessQueue.get()</span>
<span class="c1">#             except:</span>
<span class="c1">#                 return False, None</span>
<span class="c1">#</span>
<span class="c1">#         def putActionObject(self, actionObject):</span>
<span class="c1">#             self.channelAccessQueue.put(actionObject)</span>
<span class="c1">#             return True</span>
<span class="c1">#</span>
<span class="c1">#     class channelPriorityThread(threading.Thread):</span>
<span class="c1">#         &#39;&#39;&#39;Releases actionObjects to the channelAccessQueue, and when necessary first serializes actionSets into a series of action objects.&#39;&#39;&#39;</span>
<span class="c1">#</span>
<span class="c1">#         def __init__(self, interface):</span>
<span class="c1">#             threading.Thread.__init__(self)</span>
<span class="c1">#             self.interface = interface</span>
<span class="c1">#             self.channelPriorityQueue = Queue.Queue()</span>
<span class="c1">#</span>
<span class="c1">#         def run(self):</span>
<span class="c1">#             while True:</span>
<span class="c1">#                 priorityQueueState, actionObject = self.getActionObject()  # get the next actionObject or actionSet from the queue.</span>
<span class="c1">#                 if priorityQueueState:</span>
<span class="c1">#                     while not actionObject.isReleased():  # wait for actionObject or actionSet to be released</span>
<span class="c1">#                         time.sleep(0.0005)</span>
<span class="c1">#                     for thisActionObject in self.serialize(actionObject):</span>
<span class="c1">#                         self.interface.channelAccess.putActionObject(</span>
<span class="c1">#                             thisActionObject)  # transfer action object to the channel access thread.</span>
<span class="c1">#                 time.sleep(0.0005)</span>
<span class="c1">#</span>
<span class="c1">#         def serialize(self, actionObject):</span>
<span class="c1">#             &#39;&#39;&#39;serializes actionSets into actionObjects.&#39;&#39;&#39;</span>
<span class="c1">#             if actionObject._type_ == &#39;actionObject&#39;: return [</span>
<span class="c1">#                 actionObject]  # note _type_ is defined in the actionObject class</span>
<span class="c1">#             if actionObject._type_ == &#39;actionSet&#39;:</span>
<span class="c1">#                 if actionObject.actionObjects[0]._type_ == &#39;actionObject&#39;:</span>
<span class="c1">#                     # actionSet contains actionObjects rather than actionSequences</span>
<span class="c1">#                     actionObjectStream = [thisActionObject for thisActionObject in actionObject.actionObjects]</span>
<span class="c1">#                     actionObjectStream += [</span>
<span class="c1">#                         actionObject.actionObjects[0].virtualNode.syncRequest()]  # generates a syncRequest.</span>
<span class="c1">#                     return actionObjectStream</span>
<span class="c1">#                 if actionObject.actionObjects[0]._type_ == &#39;actionSequence&#39;:</span>
<span class="c1">#                     actionObjectStream = []</span>
<span class="c1">#                     actionSequences = [actionSequence.actionObjects for actionSequence in actionObject.actionObjects]</span>
<span class="c1">#                     syncLists = zip(</span>
<span class="c1">#                         *actionSequences)  # takes parallel slices of actionObjects in the provided actionSequences.</span>
<span class="c1">#                     for syncList in syncLists:</span>
<span class="c1">#                         actionObjectStream += syncList</span>
<span class="c1">#                         actionObjectStream += [syncList[0].virtualNode.syncRequest()]</span>
<span class="c1">#                     return actionObjectStream</span>
<span class="c1">#             return []</span>
<span class="c1">#</span>
<span class="c1">#         def getActionObject(self):</span>
<span class="c1">#             try:</span>
<span class="c1">#                 return True, self.channelPriorityQueue.get()</span>
<span class="c1">#             except:</span>
<span class="c1">#                 return False, None</span>
<span class="c1">#</span>
<span class="c1">#         def putActionObject(self, actionObject):</span>
<span class="c1">#             self.channelPriorityQueue.put(actionObject)</span>
<span class="c1">#             return True</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1"># class socketInterface(baseInterface):</span>
<span class="c1">#     def __init__(self, IPAddress=&#39;&#39;, IPPort=27272):  # all avaliable interfaces, port 27272</span>
<span class="c1">#         self.receiveIPAddress = IPAddress</span>
<span class="c1">#         self.receiveIPPort = IPPort</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1"># class socketUDPServer(socketInterface):</span>
<span class="c1">#</span>
<span class="c1">#     def initAfterSet(self):  # gets called once interface is set into shell.</span>
<span class="c1">#         self.receiveSocket = socket.socket(socket.AF_INET,</span>
<span class="c1">#                                            socket.SOCK_DGRAM)  # UDP, would be socket.SOCK_STREAM for TCP</span>
<span class="c1">#         self.receiveSocket.bind((self.receiveIPAddress, self.receiveIPPort))  # bind to socket</span>
<span class="c1">#         notice(self, &quot;opened socket on &quot; + str(self.receiveIPAddress) + &quot; port &quot; + str(self.receiveIPPort))</span>
<span class="c1">#         self.transmitSocket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span>
<span class="c1">#</span>
<span class="c1">#     def receive(self):</span>
<span class="c1">#         data, addr = self.receiveSocket.recvfrom(1024)</span>
<span class="c1">#         notice(self, &quot;&#39;&quot; + str(data) + &quot;&#39; from &quot; + str(addr))</span>
<span class="c1">#         return (data, addr)</span>
<span class="c1">#</span>
<span class="c1">#     def transmit(self, remoteIPAddress, remoteIPPort, data):</span>
<span class="c1">#         #		self.transmitSocket.sendto(data, (remoteIPAddress, remoteIPPort))</span>
<span class="c1">#         self.receiveSocket.sendto(data, (remoteIPAddress, remoteIPPort))</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1"># # ----UTILITY CLASSES---------------</span>
<span class="c1"># class CRC():</span>
<span class="c1">#     &#39;&#39;&#39;Generates CRC bytes and checks CRC validated packets.&#39;&#39;&#39;</span>
<span class="c1">#</span>
<span class="c1">#     def __init__(self):</span>
<span class="c1">#         self.polynomial = 7  # CRC-8: ATM=7, Dallas-Maxim = 49</span>
<span class="c1">#         self.crcTableGen()</span>
<span class="c1">#</span>
<span class="c1">#     def calculateByteCRC(self, byteValue):</span>
<span class="c1">#         &#39;&#39;&#39;Calculates Bytes in the CRC Table.&#39;&#39;&#39;</span>
<span class="c1">#         for i in range(8):</span>
<span class="c1">#             byteValue = byteValue &lt;&lt; 1</span>
<span class="c1">#             if (byteValue // 256) == 1:</span>
<span class="c1">#                 byteValue = byteValue - 256</span>
<span class="c1">#                 byteValue = byteValue ^ self.polynomial</span>
<span class="c1">#         return byteValue</span>
<span class="c1">#</span>
<span class="c1">#     def crcTableGen(self):</span>
<span class="c1">#         &#39;&#39;&#39;Generates a CRC table to make CRC generation faster.&#39;&#39;&#39;</span>
<span class="c1">#         self.crcTable = []</span>
<span class="c1">#         for i in range(256):</span>
<span class="c1">#             self.crcTable += [self.calculateByteCRC(i)]</span>
<span class="c1">#</span>
<span class="c1">#     def __call__(self, packet):</span>
<span class="c1">#         &#39;&#39;&#39;Generates CRC for an input packet.&#39;&#39;&#39;</span>
<span class="c1">#         # INITIALIZE CRC ALGORITHM</span>
<span class="c1">#         crc = 0</span>
<span class="c1">#         crcByte = 0</span>
<span class="c1">#</span>
<span class="c1">#         # CALCULATE CRC AND CONVERT preOutput BYTES TO CHR</span>
<span class="c1">#         output = []</span>
<span class="c1">#         for byte in packet:</span>
<span class="c1">#             crcByte = byte ^ crc</span>
<span class="c1">#             crc = self.crcTable[crcByte]</span>
<span class="c1">#             output += [byte]</span>
<span class="c1">#         output += [crc]  # write crc to output</span>
<span class="c1">#         return output  # NOTE: OUTPUT HAS BEEN CONVERTED TO A STRING</span>
<span class="c1">#</span>
<span class="c1">#     def validate(self, packet):  # NOTE: ASSUMES INPUT IS A LIST OF NUMBERS</span>
<span class="c1">#         &#39;&#39;&#39;Checks CRC byte against packet.&#39;&#39;&#39;</span>
<span class="c1">#         crc = 0</span>
<span class="c1">#         crcByte = 0</span>
<span class="c1">#         packetLength = len(packet)</span>
<span class="c1">#</span>
<span class="c1">#         for char in packet[0:packetLength]:</span>
<span class="c1">#             crcByte = char ^ crc</span>
<span class="c1">#             crc = self.crcTable[crcByte]</span>
<span class="c1">#</span>
<span class="c1">#         if crc != 0:</span>
<span class="c1">#             return False  # CRC doesn&#39;t match</span>
<span class="c1">#         else:</span>
<span class="c1">#             return True  # CRC matches</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1"># ----METHODS-----------------------</span>




</pre></div>

           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, Daniel Marquina.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'1',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>